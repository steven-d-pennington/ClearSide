# AUDIO-004: Audio Export Orchestration & ID3 Tags

**Task ID:** AUDIO-004
**Phase:** Phase 2
**Category:** Audio Export
**Priority:** P2
**Estimated Effort:** 2 days
**Dependencies:** AUDIO-001, AUDIO-002, AUDIO-003, QUEUE-001
**Status:** TO DO

---

## Overview

Orchestrate the complete audio export pipeline from script generation through TTS, audio processing, metadata tagging, and delivery. Integrate with job queue for async processing.

---

## Objectives

1. End-to-end audio export orchestration
2. Queue integration for async processing
3. Progress tracking and status updates
4. ID3 tag management
5. Error handling and cleanup

---

## Technical Specification

```typescript
// src/services/audio/audioExportOrchestrator.ts

import { DebateOutput } from '@/types/debate';
import { ScriptGenerator } from './scriptGenerator';
import { ElevenLabsService } from './elevenLabsService';
import { AudioProcessor } from './audioProcessor';
import { promises as fs } from 'fs';
import path from 'path';
import NodeID3 from 'node-id3';

export interface AudioExportJob {
  id: string;
  debateOutput: DebateOutput;
  options: AudioExportOptions;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  error?: string;
  outputUrl?: string;
}

export interface AudioExportOptions {
  includeBackgroundMusic?: boolean;
  voiceSpeed?: number;
  format?: 'mp3' | 'wav';
}

export class AudioExportOrchestrator {
  private scriptGenerator: ScriptGenerator;
  private ttsService: ElevenLabsService;
  private audioProcessor: AudioProcessor;
  private workDir: string;

  constructor(apiKey: string, workDir: string = '/tmp/audio-exports') {
    this.scriptGenerator = new ScriptGenerator();
    this.ttsService = new ElevenLabsService(apiKey);
    this.audioProcessor = new AudioProcessor();
    this.workDir = workDir;
  }

  async exportAudio(
    debateOutput: DebateOutput,
    options: AudioExportOptions = {}
  ): Promise<string> {
    const jobId = this.generateJobId();
    const jobDir = path.join(this.workDir, jobId);
    await fs.mkdir(jobDir, { recursive: true });

    try {
      // Step 1: Generate script
      const script = this.scriptGenerator.generate(debateOutput);

      // Step 2: Generate TTS for each segment
      const segmentPaths: string[] = [];
      for (let i = 0; i < script.segments.length; i++) {
        const segment = script.segments[i];
        const audioBuffer = await this.ttsService.generateSpeech(
          segment.ssml,
          segment.voiceType === 'narrator' ? 'moderator' : segment.voiceType
        );

        const segmentPath = path.join(jobDir, `segment-${i}.mp3`);
        await fs.writeFile(segmentPath, audioBuffer);
        segmentPaths.push(segmentPath);

        // Update progress
        this.updateProgress(jobId, (i + 1) / script.segments.length * 50);
      }

      // Step 3: Concatenate segments
      const concatenatedPath = path.join(jobDir, 'concatenated.mp3');
      await this.audioProcessor.concatenateSegments(segmentPaths, concatenatedPath);
      this.updateProgress(jobId, 60);

      // Step 4: Normalize audio
      const normalizedPath = path.join(jobDir, 'normalized.mp3');
      await this.audioProcessor.normalizeAudio(concatenatedPath, normalizedPath);
      this.updateProgress(jobId, 70);

      // Step 5: Add background music (optional)
      let finalAudioPath = normalizedPath;
      if (options.includeBackgroundMusic) {
        const withMusicPath = path.join(jobDir, 'with-music.mp3');
        await this.audioProcessor.addBackgroundMusic(
          normalizedPath,
          path.join(__dirname, '../assets/background-music.mp3'),
          withMusicPath
        );
        finalAudioPath = withMusicPath;
        this.updateProgress(jobId, 80);
      }

      // Step 6: Add ID3 tags
      const outputPath = path.join(jobDir, 'final.mp3');
      await this.addID3Tags(finalAudioPath, outputPath, debateOutput);
      this.updateProgress(jobId, 90);

      // Step 7: Cleanup temp files
      await this.cleanup(jobDir, ['final.mp3']);
      this.updateProgress(jobId, 100);

      return outputPath;
    } catch (error) {
      console.error('Audio export failed:', error);
      await this.cleanup(jobDir);
      throw error;
    }
  }

  private async addID3Tags(
    inputPath: string,
    outputPath: string,
    debateOutput: DebateOutput
  ): Promise<void> {
    const tags: NodeID3.Tags = {
      title: debateOutput.proposition.normalized,
      artist: 'ClearSide AI Debate',
      album: 'Debate Analysis',
      year: new Date().getFullYear().toString(),
      comment: {
        language: 'eng',
        text: `Generated by ClearSide on ${new Date().toISOString()}`,
      },
      genre: 'Podcast',
    };

    await fs.copyFile(inputPath, outputPath);
    NodeID3.write(tags, outputPath);
  }

  private async cleanup(dir: string, keep: string[] = []): Promise<void> {
    const files = await fs.readdir(dir);
    for (const file of files) {
      if (!keep.includes(file)) {
        await fs.unlink(path.join(dir, file)).catch(() => {});
      }
    }
  }

  private generateJobId(): string {
    return `audio-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }

  private updateProgress(jobId: string, progress: number): void {
    // Emit progress event for real-time updates
    console.log(`Job ${jobId}: ${progress}%`);
  }
}
```

---

**Last Updated:** 2025-12-23
