# UI-007: Error Handling & Loading States

**Task ID:** UI-007
**Phase:** Phase 1 - MVP
**Category:** UI
**Priority:** P1 (High - UX Polish)
**Estimated Effort:** 2 days
**Dependencies:** UI-001, UI-002, UI-006
**Status:** TO DO

---

## Overview

Implement comprehensive error handling UI and loading states across all components. This includes error boundaries, retry mechanisms, skeleton loaders, and user-friendly error messages.

### Related Documentation
- **Requirements:** `docs/REQUIREMENTS.md` - Non-functional requirements
- **Product Vision:** `docs/01_product-vision.md` - User experience principles

---

## Objectives

1. **Error boundaries** to catch React errors
2. **Skeleton loaders** for async content
3. **Retry mechanisms** for failed requests
4. **User-friendly error messages**
5. **Network status indicator**
6. **Timeout handling**

---

## Acceptance Criteria

- [ ] Error boundary catches and displays errors gracefully
- [ ] Skeleton loaders match component shapes
- [ ] Retry button available for failed requests
- [ ] Error messages are actionable
- [ ] Loading states don't cause layout shift
- [ ] Network status shows connection issues
- [ ] Timeout errors provide clear messaging

---

## Technical Specification

### Error Boundary

```typescript
// src/components/ErrorBoundary/ErrorBoundary.tsx

import React, { Component, ErrorInfo } from 'react';
import { Button } from '@/components/ui/Button';
import { Alert } from '@/components/ui/Alert';
import styles from './ErrorBoundary.module.css';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught error:', error, errorInfo);
    this.props.onError?.(error, errorInfo);

    // Log to error tracking service (e.g., Sentry)
    // logErrorToService(error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className={styles.errorBoundary}>
          <Alert variant="error">
            <h3>Something went wrong</h3>
            <p>
              {this.state.error?.message ||
                'An unexpected error occurred. Please try again.'}
            </p>
            <Button onClick={this.handleReset} variant="primary" size="sm">
              Try Again
            </Button>
          </Alert>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Skeleton Loader Components

```typescript
// src/components/ui/SkeletonLoader/SkeletonLoader.tsx

import React from 'react';
import styles from './SkeletonLoader.module.css';

export type SkeletonVariant = 'proposition' | 'arguments' | 'synthesis' | 'text' | 'circle';

interface SkeletonLoaderProps {
  variant: SkeletonVariant;
  title?: string;
  count?: number;
}

export const SkeletonLoader: React.FC<SkeletonLoaderProps> = ({
  variant,
  title,
  count = 3,
}) => {
  if (variant === 'text') {
    return (
      <div className={styles.textSkeleton}>
        <div className={styles.line} style={{ width: '100%' }} />
        <div className={styles.line} style={{ width: '95%' }} />
        <div className={styles.line} style={{ width: '90%' }} />
      </div>
    );
  }

  if (variant === 'circle') {
    return <div className={styles.circleSkeleton} />;
  }

  if (variant === 'proposition') {
    return (
      <div className={styles.propositionSkeleton}>
        <div className={styles.header}>
          <div className={styles.line} style={{ width: '200px', height: '24px' }} />
        </div>
        <div className={styles.body}>
          <div className={styles.line} style={{ width: '100%' }} />
          <div className={styles.line} style={{ width: '85%' }} />
        </div>
      </div>
    );
  }

  if (variant === 'arguments') {
    return (
      <div className={styles.argumentsSkeleton}>
        {title && <h3 className={styles.title}>{title}</h3>}
        {Array.from({ length: count }).map((_, i) => (
          <div key={i} className={styles.argumentCard}>
            <div className={styles.line} style={{ width: '70%', height: '20px' }} />
            <div className={styles.line} style={{ width: '100%' }} />
            <div className={styles.line} style={{ width: '95%' }} />
            <div className={styles.line} style={{ width: '60%' }} />
          </div>
        ))}
      </div>
    );
  }

  if (variant === 'synthesis') {
    return (
      <div className={styles.synthesisSkeleton}>
        {title && <h3 className={styles.title}>{title}</h3>}
        <div className={styles.line} style={{ width: '100%' }} />
        <div className={styles.line} style={{ width: '90%' }} />
        <div className={styles.line} style={{ width: '95%' }} />
        <div className={styles.line} style={{ width: '80%' }} />
      </div>
    );
  }

  return null;
};
```

```css
/* src/components/ui/SkeletonLoader/SkeletonLoader.module.css */

.line,
.circleSkeleton,
.propositionSkeleton,
.argumentCard {
  background: linear-gradient(
    90deg,
    var(--color-bg-secondary) 0%,
    var(--color-bg-tertiary) 50%,
    var(--color-bg-secondary) 100%
  );
  background-size: 200% 100%;
  animation: skeleton-loading 1.5s ease-in-out infinite;
  border-radius: var(--radius-sm);
}

@keyframes skeleton-loading {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}

.textSkeleton {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-sm);
}

.line {
  height: 16px;
  border-radius: var(--radius-sm);
}

.circleSkeleton {
  width: 48px;
  height: 48px;
  border-radius: 50%;
}

.propositionSkeleton {
  padding: var(--spacing-lg);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
}

.argumentsSkeleton {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-2xl);
}

.argumentCard {
  padding: var(--spacing-lg);
  border-radius: var(--radius-md);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.synthesisSkeleton {
  padding: var(--spacing-lg);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.title {
  margin-bottom: var(--spacing-md);
  color: var(--color-text-secondary);
}
```

### Error Display Component

```typescript
// src/components/ErrorDisplay/ErrorDisplay.tsx

import React from 'react';
import { Alert } from '@/components/ui/Alert';
import { Button } from '@/components/ui/Button';
import styles from './ErrorDisplay.module.css';

interface ErrorDisplayProps {
  error: Error | string;
  onRetry?: () => void;
  retryLabel?: string;
  className?: string;
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  onRetry,
  retryLabel = 'Try Again',
  className = '',
}) => {
  const errorMessage = typeof error === 'string' ? error : error.message;

  // Categorize error types
  const isNetworkError = errorMessage.toLowerCase().includes('network');
  const isTimeoutError = errorMessage.toLowerCase().includes('timeout');
  const is404Error = errorMessage.includes('404');

  let title = 'Something went wrong';
  let description = errorMessage;
  let suggestions: string[] = [];

  if (isNetworkError) {
    title = 'Connection Error';
    description = 'Unable to connect to the server.';
    suggestions = [
      'Check your internet connection',
      'Try refreshing the page',
      'Contact support if the issue persists',
    ];
  } else if (isTimeoutError) {
    title = 'Request Timeout';
    description = 'The request took too long to complete.';
    suggestions = [
      'The server may be busy. Please try again.',
      'Check your internet connection speed',
    ];
  } else if (is404Error) {
    title = 'Not Found';
    description = 'The requested resource could not be found.';
    suggestions = ['The URL may be incorrect', 'The resource may have been moved or deleted'];
  }

  return (
    <div className={`${styles.errorDisplay} ${className}`}>
      <Alert variant="error">
        <h3>{title}</h3>
        <p>{description}</p>

        {suggestions.length > 0 && (
          <ul className={styles.suggestions}>
            {suggestions.map((suggestion, i) => (
              <li key={i}>{suggestion}</li>
            ))}
          </ul>
        )}

        {onRetry && (
          <Button onClick={onRetry} variant="primary" size="sm">
            {retryLabel}
          </Button>
        )}
      </Alert>
    </div>
  );
};
```

### Loading Spinner Component

```typescript
// src/components/ui/LoadingSpinner/LoadingSpinner.tsx

import React from 'react';
import styles from './LoadingSpinner.module.css';

export type SpinnerSize = 'sm' | 'md' | 'lg';

interface LoadingSpinnerProps {
  size?: SpinnerSize;
  label?: string;
  className?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  label,
  className = '',
}) => {
  return (
    <div
      className={`${styles.spinner} ${styles[size]} ${className}`}
      role="status"
      aria-label={label || 'Loading'}
    >
      <svg className={styles.svg} viewBox="0 0 50 50">
        <circle
          className={styles.circle}
          cx="25"
          cy="25"
          r="20"
          fill="none"
          strokeWidth="4"
        />
      </svg>
      {label && <span className={styles.label}>{label}</span>}
    </div>
  );
};
```

```css
/* src/components/ui/LoadingSpinner/LoadingSpinner.module.css */

.spinner {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  gap: var(--spacing-sm);
}

.svg {
  animation: rotate 2s linear infinite;
}

.sm .svg { width: 20px; height: 20px; }
.md .svg { width: 40px; height: 40px; }
.lg .svg { width: 60px; height: 60px; }

.circle {
  stroke: var(--color-primary);
  stroke-linecap: round;
  animation: dash 1.5s ease-in-out infinite;
}

@keyframes rotate {
  100% {
    transform: rotate(360deg);
  }
}

@keyframes dash {
  0% {
    stroke-dasharray: 1, 150;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -35;
  }
  100% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -124;
  }
}

.label {
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
}
```

### Network Status Indicator

```typescript
// src/components/NetworkStatus/NetworkStatus.tsx

import React, { useState, useEffect } from 'react';
import { Alert } from '@/components/ui/Alert';
import styles from './NetworkStatus.module.css';

export const NetworkStatus: React.FC = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [showOfflineMessage, setShowOfflineMessage] = useState(false);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      setShowOfflineMessage(false);
    };

    const handleOffline = () => {
      setIsOnline(false);
      setShowOfflineMessage(true);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  if (!showOfflineMessage) return null;

  return (
    <div className={styles.networkStatus}>
      <Alert variant={isOnline ? 'success' : 'warning'}>
        {isOnline ? (
          <p>Connection restored</p>
        ) : (
          <p>
            <strong>No internet connection.</strong> Some features may not work properly.
          </p>
        )}
      </Alert>
    </div>
  );
};
```

---

## Testing Requirements

```typescript
// src/components/ErrorBoundary/ErrorBoundary.test.tsx

import { render, screen } from '@testing-library/react';
import { ErrorBoundary } from './ErrorBoundary';

const ThrowError = () => {
  throw new Error('Test error');
};

describe('ErrorBoundary', () => {
  beforeEach(() => {
    // Suppress console errors in tests
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('renders children when no error', () => {
    render(
      <ErrorBoundary>
        <div>Content</div>
      </ErrorBoundary>
    );

    expect(screen.getByText('Content')).toBeInTheDocument();
  });

  it('renders error UI when error thrown', () => {
    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
  });

  it('calls onError callback', () => {
    const onError = jest.fn();

    render(
      <ErrorBoundary onError={onError}>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(onError).toHaveBeenCalled();
  });
});
```

---

## Implementation Steps

1. **Day 1:** Implement ErrorBoundary and SkeletonLoader components
2. **Day 2:** Create ErrorDisplay, LoadingSpinner, NetworkStatus components

---

## Validation Steps

- [ ] ErrorBoundary catches errors
- [ ] Skeleton loaders match component shapes
- [ ] Error messages are user-friendly
- [ ] Retry mechanisms work
- [ ] Loading states don't cause CLS
- [ ] Network status displays correctly
- [ ] All tests pass

---

**Last Updated:** 2025-12-23
