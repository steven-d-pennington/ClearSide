# UI-004: Challenge/Intervention Forms

**Task ID:** UI-004
**Phase:** Phase 1 - MVP
**Category:** UI
**Priority:** P1 (High - Core Feature)
**Estimated Effort:** 3-4 days
**Dependencies:** UI-002 (Results Display), AGENT-005 (Challenge Agent)
**Status:** TO DO

---

## Overview

Create interactive challenge/intervention forms that allow users to question arguments, challenge assumptions, or request deeper exploration of specific points. This is a key differentiator for ClearSide - enabling users to actively engage with the reasoning rather than passively consuming it.

### Related Documentation
- **Requirements:** `docs/REQUIREMENTS.md` - User Story US-004
- **Product Vision:** `docs/01_product-vision.md` - User autonomy principle
- **JSON Schema:** `docs/04_json-schema.md` - challenges section
- **Kanban:** `docs/KANBAN.md` - Task UI-004

---

## Objectives

1. **Contextual challenge buttons** on arguments and assumptions
2. **Challenge type selection** (question assumption, request evidence, explore deeper, etc.)
3. **Free-form text input** for user's challenge
4. **Inline response display** showing Challenge Agent's response
5. **Challenge history** showing all past challenges
6. **Loading states** during Challenge Agent processing

---

## Acceptance Criteria

### Functional Requirements

- [ ] Challenge buttons appear on hover/tap for arguments
- [ ] Modal form opens when challenge button clicked
- [ ] User selects challenge type from preset options
- [ ] Free-form text area for detailed challenge (optional)
- [ ] Submit sends challenge to Challenge Agent
- [ ] Response displays inline with original argument
- [ ] Challenge history persists during session
- [ ] Can collapse/expand challenge responses
- [ ] Loading indicator shows during processing

### Non-Functional Requirements

- [ ] Challenge submission completes within 15s
- [ ] Form is keyboard accessible
- [ ] Works on mobile devices
- [ ] Multiple challenges can exist simultaneously
- [ ] Smooth animations for expand/collapse

### Design Requirements

- [ ] Non-intrusive challenge UI (doesn't clutter arguments)
- [ ] Clear visual hierarchy between argument and challenge
- [ ] Professional, neutral tone in challenge options
- [ ] Mobile-friendly modal/sheet on small screens

---

## Technical Specification

### Challenge Form Component

```typescript
// src/components/ChallengeForm/ChallengeForm.tsx

import React, { useState, useCallback } from 'react';
import { useChallengeArgument } from '@/hooks/useChallengeArgument';
import { Modal } from '@/components/ui/Modal';
import { Button } from '@/components/ui/Button';
import { Label } from '@/components/ui/Label';
import { Textarea } from '@/components/ui/Textarea';
import { RadioGroup } from '@/components/ui/RadioGroup';
import { Alert } from '@/components/ui/Alert';
import styles from './ChallengeForm.module.css';

export type ChallengeType =
  | 'question_assumption'
  | 'request_evidence'
  | 'explore_deeper'
  | 'alternative_view'
  | 'clarify'
  | 'custom';

interface ChallengeOption {
  type: ChallengeType;
  label: string;
  description: string;
  placeholder: string;
}

const CHALLENGE_OPTIONS: ChallengeOption[] = [
  {
    type: 'question_assumption',
    label: 'Question an Assumption',
    description: 'Challenge a key assumption underlying this argument',
    placeholder: 'Which assumption would you like to challenge and why?',
  },
  {
    type: 'request_evidence',
    label: 'Request More Evidence',
    description: 'Ask for additional evidence or data supporting this claim',
    placeholder: 'What specific evidence would you like to see?',
  },
  {
    type: 'explore_deeper',
    label: 'Explore Deeper',
    description: 'Request more detailed analysis of this point',
    placeholder: 'What aspect would you like explored in more detail?',
  },
  {
    type: 'alternative_view',
    label: 'Alternative Perspective',
    description: 'Suggest an alternative way to view this argument',
    placeholder: 'Describe the alternative perspective you have in mind...',
  },
  {
    type: 'clarify',
    label: 'Ask for Clarification',
    description: 'Request clarification on a specific aspect',
    placeholder: 'What needs clarification?',
  },
  {
    type: 'custom',
    label: 'Custom Challenge',
    description: 'Provide your own specific challenge or question',
    placeholder: 'Enter your challenge or question...',
  },
];

interface ChallengeFormProps {
  argumentId: string;
  argumentText: string;
  sessionId: string;
  onSuccess?: (challengeId: string) => void;
  onCancel?: () => void;
}

export const ChallengeForm: React.FC<ChallengeFormProps> = ({
  argumentId,
  argumentText,
  sessionId,
  onSuccess,
  onCancel,
}) => {
  const [selectedType, setSelectedType] = useState<ChallengeType>('question_assumption');
  const [challengeText, setChallengeText] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);

  const {
    mutate: submitChallenge,
    isLoading,
    error,
    reset,
  } = useChallengeArgument();

  /**
   * Get current challenge option
   */
  const currentOption = CHALLENGE_OPTIONS.find((opt) => opt.type === selectedType);

  /**
   * Handle challenge type change
   */
  const handleTypeChange = useCallback((type: ChallengeType) => {
    setSelectedType(type);
    reset(); // Clear any errors
  }, [reset]);

  /**
   * Handle challenge text change
   */
  const handleTextChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setChallengeText(e.target.value);
      if (error) reset();
    },
    [error, reset]
  );

  /**
   * Handle form submission
   */
  const handleSubmit = useCallback(
    (e: React.FormEvent) => {
      e.preventDefault();

      submitChallenge(
        {
          sessionId,
          argumentId,
          challengeType: selectedType,
          challengeText: challengeText.trim() || undefined,
        },
        {
          onSuccess: (data) => {
            setShowConfirmation(true);
            setTimeout(() => {
              onSuccess?.(data.challengeId);
              setShowConfirmation(false);
              setChallengeText('');
            }, 1500);
          },
        }
      );
    },
    [sessionId, argumentId, selectedType, challengeText, submitChallenge, onSuccess]
  );

  /**
   * Handle cancel
   */
  const handleCancel = useCallback(() => {
    setChallengeText('');
    reset();
    onCancel?.();
  }, [reset, onCancel]);

  return (
    <form onSubmit={handleSubmit} className={styles.form}>
      {/* Argument Context */}
      <div className={styles.context}>
        <Label>Challenging:</Label>
        <blockquote className={styles.argumentQuote}>{argumentText}</blockquote>
      </div>

      {/* Challenge Type Selection */}
      <div className={styles.field}>
        <Label>Challenge Type</Label>
        <RadioGroup
          value={selectedType}
          onChange={handleTypeChange}
          options={CHALLENGE_OPTIONS.map((opt) => ({
            value: opt.type,
            label: opt.label,
            description: opt.description,
          }))}
        />
      </div>

      {/* Challenge Text (Optional) */}
      <div className={styles.field}>
        <Label htmlFor="challenge-text">
          Your Challenge{' '}
          <span className={styles.optional}>(optional but recommended)</span>
        </Label>
        <Textarea
          id="challenge-text"
          value={challengeText}
          onChange={handleTextChange}
          placeholder={currentOption?.placeholder}
          rows={4}
          maxLength={1000}
          disabled={isLoading}
          className={styles.textarea}
        />
        <div className={styles.charCount}>{challengeText.length} / 1000</div>
      </div>

      {/* Error Display */}
      {error && (
        <Alert variant="error" className={styles.error}>
          {error instanceof Error
            ? error.message
            : 'Failed to submit challenge. Please try again.'}
        </Alert>
      )}

      {/* Success Confirmation */}
      {showConfirmation && (
        <Alert variant="success" className={styles.success}>
          Challenge submitted! Generating response...
        </Alert>
      )}

      {/* Actions */}
      <div className={styles.actions}>
        <Button
          type="button"
          variant="secondary"
          onClick={handleCancel}
          disabled={isLoading}
        >
          Cancel
        </Button>
        <Button
          type="submit"
          variant="primary"
          disabled={isLoading}
          loading={isLoading}
        >
          {isLoading ? 'Submitting...' : 'Submit Challenge'}
        </Button>
      </div>
    </form>
  );
};
```

### Challenge Button Component

```typescript
// src/components/ArgumentCard/ChallengeButton.tsx

import React, { useState } from 'react';
import { Modal } from '@/components/ui/Modal';
import { Button } from '@/components/ui/Button';
import { ChallengeForm } from '@/components/ChallengeForm/ChallengeForm';
import styles from './ChallengeButton.module.css';

interface ChallengeButtonProps {
  argumentId: string;
  argumentText: string;
  sessionId: string;
  onChallengeSubmit?: (challengeId: string) => void;
}

export const ChallengeButton: React.FC<ChallengeButtonProps> = ({
  argumentId,
  argumentText,
  sessionId,
  onChallengeSubmit,
}) => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleSuccess = (challengeId: string) => {
    setIsModalOpen(false);
    onChallengeSubmit?.(challengeId);
  };

  return (
    <>
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setIsModalOpen(true)}
        className={styles.challengeButton}
        aria-label="Challenge this argument"
      >
        <span className={styles.icon}>ðŸ’­</span>
        Challenge
      </Button>

      <Modal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        title="Challenge Argument"
        size="lg"
      >
        <ChallengeForm
          argumentId={argumentId}
          argumentText={argumentText}
          sessionId={sessionId}
          onSuccess={handleSuccess}
          onCancel={() => setIsModalOpen(false)}
        />
      </Modal>
    </>
  );
};
```

### Challenge Response Display

```typescript
// src/components/ArgumentCard/ChallengeResponse.tsx

import React, { useState } from 'react';
import { ChallengeResponseData } from '@/types/debate';
import { Button } from '@/components/ui/Button';
import { Badge } from '@/components/ui/Badge';
import styles from './ChallengeResponse.module.css';

interface ChallengeResponseProps {
  challenge: ChallengeResponseData;
  isLoading?: boolean;
}

export const ChallengeResponse: React.FC<ChallengeResponseProps> = ({
  challenge,
  isLoading = false,
}) => {
  const [isExpanded, setIsExpanded] = useState(true);

  return (
    <div className={styles.challengeResponse}>
      <header className={styles.header}>
        <div className={styles.headerLeft}>
          <span className={styles.icon}>ðŸ’­</span>
          <h6 className={styles.title}>Challenge Response</h6>
          <Badge variant="secondary" size="sm">
            {challenge.challengeType.replace('_', ' ')}
          </Badge>
        </div>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setIsExpanded(!isExpanded)}
          aria-label={isExpanded ? 'Collapse' : 'Expand'}
          aria-expanded={isExpanded}
        >
          {isExpanded ? 'âˆ’' : '+'}
        </Button>
      </header>

      {isExpanded && (
        <div className={styles.content}>
          {/* User's Challenge */}
          {challenge.userChallenge && (
            <div className={styles.userChallenge}>
              <strong>Your challenge:</strong>
              <p>{challenge.userChallenge}</p>
            </div>
          )}

          {/* Loading State */}
          {isLoading && (
            <div className={styles.loading}>
              <span className={styles.spinner} />
              <span>Generating response...</span>
            </div>
          )}

          {/* Agent Response */}
          {!isLoading && challenge.response && (
            <div className={styles.response}>
              <p>{challenge.response}</p>

              {/* Additional Evidence */}
              {challenge.additionalEvidence &&
                challenge.additionalEvidence.length > 0 && (
                  <div className={styles.evidence}>
                    <strong>Additional Evidence:</strong>
                    <ul>
                      {challenge.additionalEvidence.map((item, i) => (
                        <li key={i}>{item}</li>
                      ))}
                    </ul>
                  </div>
                )}

              {/* Limitations */}
              {challenge.limitations && challenge.limitations.length > 0 && (
                <div className={styles.limitations}>
                  <strong>Limitations:</strong>
                  <ul>
                    {challenge.limitations.map((item, i) => (
                      <li key={i}>{item}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

### Challenge Mutation Hook

```typescript
// src/hooks/useChallengeArgument.ts

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/apiClient';

interface ChallengeRequest {
  sessionId: string;
  argumentId: string;
  challengeType: string;
  challengeText?: string;
}

interface ChallengeResponse {
  challengeId: string;
  response: string;
  additionalEvidence?: string[];
  limitations?: string[];
}

export function useChallengeArgument() {
  const queryClient = useQueryClient();

  return useMutation<ChallengeResponse, Error, ChallengeRequest>({
    mutationFn: async (request) => {
      const response = await apiClient.post<ChallengeResponse>(
        `/api/challenge`,
        request,
        { timeout: 15000 }
      );
      return response.data;
    },
    onSuccess: (data, variables) => {
      // Invalidate debate output to refetch with new challenge
      queryClient.invalidateQueries(['debate', variables.sessionId]);
    },
  });
}
```

### Styling

```css
/* src/components/ChallengeForm/ChallengeForm.module.css */

.form {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.context {
  background: var(--color-bg-secondary);
  padding: 1rem;
  border-radius: 4px;
  border-left: 3px solid var(--color-primary);
}

.argumentQuote {
  margin: 0.5rem 0 0;
  padding: 0;
  font-style: italic;
  color: var(--color-text-secondary);
  border: none;
}

.field {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.optional {
  font-weight: 400;
  color: var(--color-text-tertiary);
  font-size: 0.875rem;
}

.textarea {
  min-height: 120px;
  resize: vertical;
}

.charCount {
  text-align: right;
  font-size: 0.875rem;
  color: var(--color-text-tertiary);
}

.error,
.success {
  margin-top: 1rem;
}

.actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--color-border);
}
```

```css
/* src/components/ArgumentCard/ChallengeButton.module.css */

.challengeButton {
  opacity: 0;
  transition: opacity 0.2s ease;
}

/* Show on parent hover */
article:hover .challengeButton,
article:focus-within .challengeButton {
  opacity: 1;
}

/* Always show on touch devices */
@media (hover: none) {
  .challengeButton {
    opacity: 1;
  }
}

.icon {
  margin-right: 0.25rem;
}
```

```css
/* src/components/ArgumentCard/ChallengeResponse.module.css */

.challengeResponse {
  margin-top: 1rem;
  padding: 1rem;
  background: var(--color-challenge-bg);
  border-left: 3px solid var(--color-challenge);
  border-radius: 4px;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.headerLeft {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.icon {
  font-size: 1.25rem;
}

.title {
  font-size: 0.95rem;
  font-weight: 600;
  margin: 0;
}

.content {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.userChallenge {
  padding: 0.75rem;
  background: var(--color-bg-tertiary);
  border-radius: 4px;
}

.userChallenge strong {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  color: var(--color-text-secondary);
}

.userChallenge p {
  margin: 0;
  font-style: italic;
}

.loading {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 1rem;
  color: var(--color-text-secondary);
}

.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid var(--color-border);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.response p {
  margin: 0 0 1rem;
  line-height: 1.6;
}

.evidence,
.limitations {
  margin-top: 1rem;
}

.evidence strong,
.limitations strong {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
}

.evidence ul,
.limitations ul {
  margin: 0;
  padding-left: 1.5rem;
}

.evidence li,
.limitations li {
  margin-bottom: 0.5rem;
}
```

---

## Testing Requirements

```typescript
// src/components/ChallengeForm/ChallengeForm.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ChallengeForm } from './ChallengeForm';
import { useChallengeArgument } from '@/hooks/useChallengeArgument';

jest.mock('@/hooks/useChallengeArgument');

describe('ChallengeForm', () => {
  const mockSubmit = jest.fn();

  beforeEach(() => {
    (useChallengeArgument as jest.Mock).mockReturnValue({
      mutate: mockSubmit,
      isLoading: false,
      error: null,
      reset: jest.fn(),
    });
  });

  it('renders challenge type options', () => {
    render(
      <ChallengeForm
        argumentId="arg-1"
        argumentText="Test argument"
        sessionId="session-1"
      />
    );

    expect(screen.getByText('Question an Assumption')).toBeInTheDocument();
    expect(screen.getByText('Request More Evidence')).toBeInTheDocument();
    expect(screen.getByText('Explore Deeper')).toBeInTheDocument();
  });

  it('allows selecting challenge type', async () => {
    const user = userEvent.setup();
    render(
      <ChallengeForm
        argumentId="arg-1"
        argumentText="Test argument"
        sessionId="session-1"
      />
    );

    const evidenceOption = screen.getByLabelText('Request More Evidence');
    await user.click(evidenceOption);

    expect(evidenceOption).toBeChecked();
  });

  it('submits challenge with selected type and text', async () => {
    const user = userEvent.setup();
    const onSuccess = jest.fn();

    mockSubmit.mockImplementation((_, { onSuccess: cb }) => {
      cb({ challengeId: 'challenge-1' });
    });

    render(
      <ChallengeForm
        argumentId="arg-1"
        argumentText="Test argument"
        sessionId="session-1"
        onSuccess={onSuccess}
      />
    );

    const textarea = screen.getByPlaceholderText(/which assumption/i);
    await user.type(textarea, 'I challenge this assumption because...');

    const submitButton = screen.getByRole('button', { name: /submit challenge/i });
    await user.click(submitButton);

    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          sessionId: 'session-1',
          argumentId: 'arg-1',
          challengeType: 'question_assumption',
          challengeText: 'I challenge this assumption because...',
        }),
        expect.any(Object)
      );
    });
  });
});
```

---

## Implementation Steps

1. **Day 1:** Build ChallengeForm component with type selection
2. **Day 2:** Implement ChallengeButton and modal integration
3. **Day 3:** Create ChallengeResponse display component
4. **Day 4:** Write tests and accessibility improvements

---

## Validation Steps

- [ ] Challenge buttons appear correctly
- [ ] Modal opens and closes properly
- [ ] All challenge types work
- [ ] Text input saves correctly
- [ ] Submission calls API correctly
- [ ] Responses display inline
- [ ] Keyboard accessible
- [ ] Mobile responsive
- [ ] Tests pass

---

## Implementation Notes from Completed Tasks

> Added 2025-12-24 after completing UI-001, UI-002, UI-006, TEST-001

### Available Resources

- **UI Components**: Modal, Button, Textarea, Badge, Alert already exist in `frontend/src/components/ui/`
- **Design tokens**: `frontend/src/styles/tokens.css` - use existing CSS variables
- **Zustand store**: `frontend/src/stores/debate-store.ts` - has `submitIntervention` action
- **Types**: Intervention type in `frontend/src/types/debate.ts`

### Important Notes

1. **Use Vitest, not Jest** for tests - see `frontend/src/test-utils/` for utilities
2. **Don't use TypeScript enums** - use const objects (see `frontend/src/types/debate.ts`)
3. **Use CSS Modules** - all components use `*.module.css` pattern
4. **Interventions in store**: The store already has intervention handling - use `submitIntervention`

### Related Files

- `frontend/src/components/ui/Modal/Modal.tsx` - Use for challenge modal
- `frontend/src/components/ui/Textarea/Textarea.tsx` - Use for challenge text
- `frontend/src/stores/debate-store.ts` - Has `interventions`, `submitIntervention`
- `frontend/src/types/debate.ts` - Intervention interface

---

**Last Updated:** 2025-12-24
