# UI-009: Performance Optimization

**Task ID:** UI-009
**Phase:** Phase 1 - MVP
**Category:** UI
**Priority:** P2 (Medium - Polish)
**Estimated Effort:** 2-3 days
**Dependencies:** All UI components
**Status:** TO DO

---

## Overview

Optimize frontend performance for fast load times, smooth interactions, and efficient resource usage. Implement code splitting, lazy loading, memoization, virtual scrolling, and performance monitoring.

### Related Documentation
- **Requirements:** `docs/REQUIREMENTS.md` - Performance requirements
- **Product Vision:** `docs/01_product-vision.md` - User experience goals

---

## Objectives

1. **Code splitting** for smaller initial bundle
2. **Lazy loading** for route-based components
3. **Memoization** to prevent unnecessary re-renders
4. **Virtual scrolling** for long lists
5. **Image optimization** with lazy loading
6. **Performance monitoring** with Web Vitals

---

## Acceptance Criteria

- [ ] Initial bundle size < 200KB (gzipped)
- [ ] Time to Interactive (TTI) < 3s on 3G
- [ ] First Contentful Paint (FCP) < 1.5s
- [ ] Largest Contentful Paint (LCP) < 2.5s
- [ ] Cumulative Layout Shift (CLS) < 0.1
- [ ] No unnecessary re-renders (verified with React DevTools)
- [ ] Long lists use virtual scrolling
- [ ] Images lazy load below the fold

---

## Technical Specification

### Code Splitting & Lazy Loading

```typescript
// src/App.tsx

import React, { Suspense, lazy } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AppLayout } from '@/components/Layout/AppLayout';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import { ErrorBoundary } from '@/components/ErrorBoundary';

// Lazy load route components
const HomePage = lazy(() => import('@/pages/HomePage'));
const AnalysisPage = lazy(() => import('@/pages/AnalysisPage'));
const HowItWorksPage = lazy(() => import('@/pages/HowItWorksPage'));
const ExamplesPage = lazy(() => import('@/pages/ExamplesPage'));
const DocsPage = lazy(() => import('@/pages/DocsPage'));

function App() {
  return (
    <BrowserRouter>
      <ErrorBoundary>
        <AppLayout>
          <Suspense
            fallback={
              <div style={{ padding: '2rem', textAlign: 'center' }}>
                <LoadingSpinner size="lg" label="Loading..." />
              </div>
            }
          >
            <Routes>
              <Route path="/" element={<HomePage />} />
              <Route path="/analyze/:sessionId" element={<AnalysisPage />} />
              <Route path="/how-it-works" element={<HowItWorksPage />} />
              <Route path="/examples" element={<ExamplesPage />} />
              <Route path="/docs" element={<DocsPage />} />
            </Routes>
          </Suspense>
        </AppLayout>
      </ErrorBoundary>
    </BrowserRouter>
  );
}

export default App;
```

### Memoization Utilities

```typescript
// src/components/ArgumentCard/ArgumentCard.tsx

import React, { memo } from 'react';
import { Argument } from '@/types/debate';

interface ArgumentCardProps {
  argument: Argument;
  index: number;
  onChallenge?: (argumentId: string) => void;
}

/**
 * Memoized ArgumentCard - only re-renders when props change
 */
export const ArgumentCard = memo<ArgumentCardProps>(
  ({ argument, index, onChallenge }) => {
    return (
      <article className="argument-card">
        <h5>{argument.title}</h5>
        <p>{argument.description}</p>
        {/* ... rest of component */}
      </article>
    );
  },
  // Custom comparison function
  (prevProps, nextProps) => {
    return (
      prevProps.argument.id === nextProps.argument.id &&
      prevProps.index === nextProps.index &&
      prevProps.onChallenge === nextProps.onChallenge
    );
  }
);

ArgumentCard.displayName = 'ArgumentCard';
```

```typescript
// src/hooks/useDebounce.ts

import { useState, useEffect } from 'react';

/**
 * Debounce a value to prevent excessive updates
 */
export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

```typescript
// src/hooks/useThrottle.ts

import { useRef, useCallback } from 'react';

/**
 * Throttle a callback function
 */
export function useThrottle<T extends (...args: any[]) => any>(
  callback: T,
  delay: number = 500
): T {
  const lastRun = useRef(Date.now());

  return useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now();

      if (now - lastRun.current >= delay) {
        lastRun.current = now;
        return callback(...args);
      }
    },
    [callback, delay]
  ) as T;
}
```

### Virtual Scrolling

```typescript
// src/components/VirtualList/VirtualList.tsx

import React, { useState, useEffect, useRef, useCallback } from 'react';

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  overscan?: number;
}

/**
 * Virtual scrolling for long lists
 * Only renders visible items + overscan buffer
 */
export function VirtualList<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 3,
}: VirtualListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  // Calculate visible range
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
  const endIndex = Math.min(
    items.length - 1,
    Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
  );

  const visibleItems = items.slice(startIndex, endIndex + 1);
  const offsetY = startIndex * itemHeight;

  // Handle scroll
  const handleScroll = useCallback(() => {
    if (containerRef.current) {
      setScrollTop(containerRef.current.scrollTop);
    }
  }, []);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    container.addEventListener('scroll', handleScroll, { passive: true });
    return () => container.removeEventListener('scroll', handleScroll);
  }, [handleScroll]);

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto',
        position: 'relative',
      }}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, i) => (
            <div key={startIndex + i} style={{ height: itemHeight }}>
              {renderItem(item, startIndex + i)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### Image Lazy Loading

```typescript
// src/components/LazyImage/LazyImage.tsx

import React, { useState, useEffect, useRef } from 'react';

interface LazyImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {
  src: string;
  alt: string;
  placeholder?: string;
}

/**
 * Lazy-loaded image with intersection observer
 */
export const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  placeholder = 'data:image/svg+xml,...', // Tiny placeholder
  ...props
}) => {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoaded, setIsLoaded] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    if (!imgRef.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setImageSrc(src);
            observer.disconnect();
          }
        });
      },
      { rootMargin: '50px' }
    );

    observer.observe(imgRef.current);

    return () => observer.disconnect();
  }, [src]);

  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      onLoad={() => setIsLoaded(true)}
      style={{
        opacity: isLoaded ? 1 : 0.5,
        transition: 'opacity 0.3s ease',
      }}
      {...props}
    />
  );
};
```

### Web Vitals Monitoring

```typescript
// src/utils/performance/webVitals.ts

import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

interface WebVitalsMetric {
  name: string;
  value: number;
  rating: 'good' | 'needs-improvement' | 'poor';
}

/**
 * Monitor Core Web Vitals
 */
export function reportWebVitals(onMetric?: (metric: WebVitalsMetric) => void) {
  const handleMetric = (metric: any) => {
    const { name, value, rating } = metric;

    console.log(`[Web Vitals] ${name}:`, value, rating);

    // Send to analytics
    if (onMetric) {
      onMetric({ name, value, rating });
    }

    // Send to monitoring service (e.g., Google Analytics)
    if (typeof window !== 'undefined' && (window as any).gtag) {
      (window as any).gtag('event', name, {
        value: Math.round(value),
        event_category: 'Web Vitals',
        event_label: rating,
        non_interaction: true,
      });
    }
  };

  getCLS(handleMetric);
  getFID(handleMetric);
  getFCP(handleMetric);
  getLCP(handleMetric);
  getTTFB(handleMetric);
}
```

```typescript
// src/index.tsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { reportWebVitals } from './utils/performance/webVitals';
import './styles/index.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Monitor performance
reportWebVitals((metric) => {
  // Send to analytics service
  console.log('Web Vitals:', metric);
});
```

### Bundle Analysis Configuration

```javascript
// webpack.config.js (or vite.config.js)

import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer';

export default {
  // ... other config
  plugins: [
    process.env.ANALYZE && new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      reportFilename: 'bundle-report.html',
      openAnalyzer: true,
    }),
  ].filter(Boolean),
};
```

```json
// package.json

{
  "scripts": {
    "build": "vite build",
    "build:analyze": "ANALYZE=true vite build",
    "lighthouse": "lighthouse http://localhost:3000 --view"
  }
}
```

### Performance Testing

```typescript
// src/tests/performance/rendering.test.tsx

import { render } from '@testing-library/react';
import { measureRenderTime } from '@/utils/testing/performance';
import { ArgumentCard } from '@/components/ArgumentCard';

describe('Performance', () => {
  it('ArgumentCard renders in < 16ms (60fps)', () => {
    const argument = {
      id: 'arg-1',
      title: 'Test Argument',
      description: 'Test description',
      category: 'economic',
    };

    const renderTime = measureRenderTime(() => {
      render(<ArgumentCard argument={argument} index={0} />);
    });

    expect(renderTime).toBeLessThan(16); // 60fps = 16.67ms per frame
  });

  it('Rendering 100 ArgumentCards is optimized', () => {
    const arguments = Array.from({ length: 100 }, (_, i) => ({
      id: `arg-${i}`,
      title: `Argument ${i}`,
      description: `Description ${i}`,
      category: 'economic',
    }));

    const renderTime = measureRenderTime(() => {
      arguments.forEach((arg, i) => {
        render(<ArgumentCard argument={arg} index={i} />);
      });
    });

    // Should complete in reasonable time
    expect(renderTime).toBeLessThan(1000); // 1 second
  });
});
```

```typescript
// src/utils/testing/performance.ts

/**
 * Measure render time of a function
 */
export function measureRenderTime(fn: () => void): number {
  const start = performance.now();
  fn();
  const end = performance.now();
  return end - start;
}

/**
 * Measure memory usage
 */
export function measureMemory(): number {
  if ((performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
```

### Resource Hints

```html
<!-- public/index.html -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Preconnect to API domain -->
    <link rel="preconnect" href="https://api.clearside.app" />
    <link rel="dns-prefetch" href="https://api.clearside.app" />

    <!-- Preload critical fonts -->
    <link
      rel="preload"
      href="/fonts/inter-var.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />

    <!-- Preload critical CSS -->
    <link rel="preload" href="/assets/critical.css" as="style" />

    <title>ClearSide - Think both sides. Decide with clarity.</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

---

## Testing Requirements

### Lighthouse CI Configuration

```javascript
// lighthouserc.js

module.exports = {
  ci: {
    collect: {
      url: ['http://localhost:3000'],
      numberOfRuns: 3,
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }],
        'first-contentful-paint': ['error', { maxNumericValue: 1500 }],
        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }],
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
        'total-blocking-time': ['error', { maxNumericValue: 300 }],
      },
    },
    upload: {
      target: 'temporary-public-storage',
    },
  },
};
```

---

## Implementation Steps

1. **Day 1:** Implement code splitting and lazy loading
2. **Day 2:** Add memoization and virtual scrolling
3. **Day 3:** Set up performance monitoring and testing

---

## Validation Steps

- [ ] Bundle size < 200KB gzipped
- [ ] Lighthouse score > 90
- [ ] FCP < 1.5s
- [ ] LCP < 2.5s
- [ ] CLS < 0.1
- [ ] TTI < 3s on 3G
- [ ] No unnecessary re-renders (React DevTools)
- [ ] Virtual scrolling works for long lists
- [ ] Web Vitals monitored in production

---

**Last Updated:** 2025-12-23
