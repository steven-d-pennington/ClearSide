# UI-001: Input Form Component

**Task ID:** UI-001
**Phase:** Phase 1 - MVP
**Category:** UI
**Priority:** P0 (Critical - MVP Core)
**Estimated Effort:** 2-3 days
**Dependencies:** None (foundational component)
**Status:** TO DO

---

## Overview

Create the main input form component that allows users to enter their question/proposition with optional context. This is the entry point for the entire ClearSide debate experience.

### Related Documentation
- **Product Vision:** `docs/01_product-vision.md`
- **Requirements:** `docs/REQUIREMENTS.md` - User Story US-001
- **JSON Schema:** `docs/04_json-schema.md` - Input structure
- **Kanban:** `docs/KANBAN.md` - Task AGENT-001 (related)

---

## Objectives

1. **Create input form UI** with question field and optional context area
2. **Implement form validation** for question length and quality
3. **Handle submission** with loading states and error handling
4. **Integrate with Zustand state** for global state management
5. **Provide clear UX feedback** during analysis process
6. **Support paste detection** for long-form context

---

## Acceptance Criteria

### Functional Requirements

- [ ] Question input field accepts 10-500 characters
- [ ] Context textarea accepts 0-5,000 characters (optional)
- [ ] Submit button is disabled when question is invalid
- [ ] Loading state displays during API call
- [ ] Success state transitions to results view
- [ ] Error states display user-friendly messages
- [ ] Form resets after successful submission (optional)
- [ ] Character count displays for both fields
- [ ] Paste detection suggests using context field for long inputs

### Non-Functional Requirements

- [ ] Form is accessible (WCAG 2.1 AA)
- [ ] Works on mobile, tablet, desktop
- [ ] Submission completes within 30s (timeout)
- [ ] Error messages are actionable
- [ ] Loading indicator is clear and visible

### Design Requirements

- [ ] Clean, minimal interface (matches product vision)
- [ ] Professional tone (no chatbot aesthetics)
- [ ] Focus on clarity over decoration
- [ ] Textarea auto-expands (up to max height)
- [ ] Smooth transitions between states

---

## Technical Specification

### Component Architecture

```typescript
// src/components/InputForm/InputForm.tsx

import React, { useState, useCallback, useEffect } from 'react';
import { useDebateStore } from '@/stores/debateStore';
import { useAnalysisMutation } from '@/hooks/useAnalysisMutation';
import { validateQuestion, validateContext } from '@/utils/validation';
import { Button } from '@/components/ui/Button';
import { Textarea } from '@/components/ui/Textarea';
import { Label } from '@/components/ui/Label';
import { Alert } from '@/components/ui/Alert';
import { CharacterCount } from '@/components/ui/CharacterCount';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import styles from './InputForm.module.css';

interface InputFormProps {
  onSuccess?: (sessionId: string) => void;
  onError?: (error: Error) => void;
  className?: string;
}

interface FormState {
  question: string;
  context: string;
}

interface ValidationErrors {
  question?: string;
  context?: string;
}

export const InputForm: React.FC<InputFormProps> = ({
  onSuccess,
  onError,
  className = '',
}) => {
  // Local form state
  const [formState, setFormState] = useState<FormState>({
    question: '',
    context: '',
  });

  const [errors, setErrors] = useState<ValidationErrors>({});
  const [touched, setTouched] = useState<Set<string>>(new Set());

  // Global state
  const setCurrentSession = useDebateStore((state) => state.setCurrentSession);
  const clearSession = useDebateStore((state) => state.clearSession);

  // API mutation
  const {
    mutate: startAnalysis,
    isLoading,
    error: apiError,
    reset: resetMutation,
  } = useAnalysisMutation();

  /**
   * Validate form fields
   */
  const validate = useCallback((): ValidationErrors => {
    const newErrors: ValidationErrors = {};

    const questionError = validateQuestion(formState.question);
    if (questionError) {
      newErrors.question = questionError;
    }

    if (formState.context) {
      const contextError = validateContext(formState.context);
      if (contextError) {
        newErrors.context = contextError;
      }
    }

    return newErrors;
  }, [formState]);

  /**
   * Update validation errors on form change
   */
  useEffect(() => {
    const newErrors = validate();
    setErrors(newErrors);
  }, [formState, validate]);

  /**
   * Handle question input change
   */
  const handleQuestionChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      const value = e.target.value;
      setFormState((prev) => ({ ...prev, question: value }));

      // Mark as touched
      setTouched((prev) => new Set(prev).add('question'));

      // Reset API error on change
      if (apiError) {
        resetMutation();
      }
    },
    [apiError, resetMutation]
  );

  /**
   * Handle context input change
   */
  const handleContextChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      const value = e.target.value;
      setFormState((prev) => ({ ...prev, context: value }));

      // Mark as touched
      setTouched((prev) => new Set(prev).add('context'));
    },
    []
  );

  /**
   * Handle paste event - suggest context field for long pastes
   */
  const handleQuestionPaste = useCallback(
    (e: React.ClipboardEvent<HTMLTextAreaElement>) => {
      const pastedText = e.clipboardData.getData('text');

      if (pastedText.length > 200 && !formState.context) {
        // Suggest moving long text to context field
        e.preventDefault();

        const confirmed = window.confirm(
          'This looks like a longer text. Would you like to use the context field instead?'
        );

        if (confirmed) {
          setFormState((prev) => ({
            ...prev,
            context: pastedText,
          }));
        } else {
          // Allow paste but truncate to max length
          const truncated = pastedText.slice(0, 500);
          setFormState((prev) => ({
            ...prev,
            question: truncated,
          }));
        }
      }
    },
    [formState.context]
  );

  /**
   * Handle form submission
   */
  const handleSubmit = useCallback(
    (e: React.FormEvent) => {
      e.preventDefault();

      // Mark all fields as touched
      setTouched(new Set(['question', 'context']));

      // Validate
      const validationErrors = validate();
      if (Object.keys(validationErrors).length > 0) {
        setErrors(validationErrors);
        return;
      }

      // Clear previous session
      clearSession();

      // Start analysis
      startAnalysis(
        {
          question: formState.question.trim(),
          context: formState.context.trim() || undefined,
        },
        {
          onSuccess: (data) => {
            setCurrentSession(data.sessionId, data.proposition);
            onSuccess?.(data.sessionId);

            // Optionally reset form
            // setFormState({ question: '', context: '' });
            // setTouched(new Set());
          },
          onError: (err) => {
            console.error('Analysis failed:', err);
            onError?.(err as Error);
          },
        }
      );
    },
    [
      formState,
      validate,
      clearSession,
      startAnalysis,
      setCurrentSession,
      onSuccess,
      onError,
    ]
  );

  /**
   * Determine if submit button should be disabled
   */
  const isSubmitDisabled =
    isLoading || !formState.question.trim() || Object.keys(errors).length > 0;

  return (
    <form
      onSubmit={handleSubmit}
      className={`${styles.inputForm} ${className}`}
      noValidate
    >
      <div className={styles.header}>
        <h1 className={styles.title}>Think both sides. Decide with clarity.</h1>
        <p className={styles.description}>
          Enter a question or proposition to explore structured arguments for and
          against.
        </p>
      </div>

      {/* Question Field */}
      <div className={styles.field}>
        <Label htmlFor="question" required>
          Your Question
        </Label>
        <Textarea
          id="question"
          name="question"
          value={formState.question}
          onChange={handleQuestionChange}
          onPaste={handleQuestionPaste}
          placeholder="Should we implement a temporary moratorium on new AI data centers?"
          maxLength={500}
          rows={3}
          disabled={isLoading}
          aria-invalid={touched.has('question') && !!errors.question}
          aria-describedby={
            errors.question ? 'question-error' : 'question-help'
          }
          className={
            touched.has('question') && errors.question ? styles.hasError : ''
          }
        />
        <CharacterCount
          current={formState.question.length}
          max={500}
          className={styles.charCount}
        />
        {touched.has('question') && errors.question && (
          <Alert id="question-error" variant="error" size="sm">
            {errors.question}
          </Alert>
        )}
        {!errors.question && (
          <p id="question-help" className={styles.helpText}>
            A clear, specific question (10-500 characters)
          </p>
        )}
      </div>

      {/* Context Field (Optional) */}
      <div className={styles.field}>
        <Label htmlFor="context">
          Additional Context <span className={styles.optional}>(optional)</span>
        </Label>
        <Textarea
          id="context"
          name="context"
          value={formState.context}
          onChange={handleContextChange}
          placeholder="Provide background information, constraints, or specific scenarios to consider..."
          maxLength={5000}
          rows={6}
          disabled={isLoading}
          aria-invalid={touched.has('context') && !!errors.context}
          aria-describedby={errors.context ? 'context-error' : 'context-help'}
          className={
            touched.has('context') && errors.context ? styles.hasError : ''
          }
        />
        <CharacterCount
          current={formState.context.length}
          max={5000}
          className={styles.charCount}
        />
        {touched.has('context') && errors.context && (
          <Alert id="context-error" variant="error" size="sm">
            {errors.context}
          </Alert>
        )}
        {!errors.context && (
          <p id="context-help" className={styles.helpText}>
            Background, constraints, or specific considerations (up to 5,000
            characters)
          </p>
        )}
      </div>

      {/* API Error Display */}
      {apiError && (
        <Alert variant="error" className={styles.apiError}>
          <strong>Analysis failed:</strong>{' '}
          {apiError instanceof Error
            ? apiError.message
            : 'An unexpected error occurred. Please try again.'}
        </Alert>
      )}

      {/* Submit Button */}
      <div className={styles.actions}>
        <Button
          type="submit"
          variant="primary"
          size="lg"
          disabled={isSubmitDisabled}
          className={styles.submitButton}
        >
          {isLoading ? (
            <>
              <LoadingSpinner size="sm" />
              <span>Analyzing...</span>
            </>
          ) : (
            'Analyze Question'
          )}
        </Button>
      </div>

      {/* Loading State Message */}
      {isLoading && (
        <div className={styles.loadingMessage}>
          <p>
            Generating structured arguments for and against your proposition...
          </p>
          <p className={styles.loadingSubtext}>This may take 20-30 seconds.</p>
        </div>
      )}
    </form>
  );
};
```

### Validation Utilities

```typescript
// src/utils/validation.ts

const QUESTION_MIN_LENGTH = 10;
const QUESTION_MAX_LENGTH = 500;
const CONTEXT_MAX_LENGTH = 5000;

/**
 * Validate question input
 */
export function validateQuestion(question: string): string | undefined {
  const trimmed = question.trim();

  if (!trimmed) {
    return 'Question is required';
  }

  if (trimmed.length < QUESTION_MIN_LENGTH) {
    return `Question must be at least ${QUESTION_MIN_LENGTH} characters`;
  }

  if (trimmed.length > QUESTION_MAX_LENGTH) {
    return `Question must be no more than ${QUESTION_MAX_LENGTH} characters`;
  }

  // Check for question mark (helpful but not required)
  if (!trimmed.includes('?') && !trimmed.toLowerCase().startsWith('should')) {
    // Soft warning, not blocking
    console.warn('Question might benefit from being phrased as a question');
  }

  return undefined;
}

/**
 * Validate context input
 */
export function validateContext(context: string): string | undefined {
  const trimmed = context.trim();

  if (trimmed.length > CONTEXT_MAX_LENGTH) {
    return `Context must be no more than ${CONTEXT_MAX_LENGTH} characters`;
  }

  return undefined;
}
```

### API Hook

```typescript
// src/hooks/useAnalysisMutation.ts

import { useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/apiClient';

interface AnalysisRequest {
  question: string;
  context?: string;
}

interface AnalysisResponse {
  sessionId: string;
  proposition: {
    normalized: string;
    original: string;
  };
}

/**
 * Mutation hook for starting debate analysis
 */
export function useAnalysisMutation() {
  return useMutation<AnalysisResponse, Error, AnalysisRequest>({
    mutationFn: async (request: AnalysisRequest) => {
      const response = await apiClient.post<AnalysisResponse>(
        '/api/analyze',
        request,
        {
          timeout: 30000, // 30s timeout
        }
      );

      return response.data;
    },
    retry: 1, // Retry once on failure
    retryDelay: 1000, // Wait 1s before retry
  });
}
```

### Zustand Store

```typescript
// src/stores/debateStore.ts

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface Proposition {
  normalized: string;
  original: string;
}

interface DebateState {
  // Current session
  currentSessionId: string | null;
  currentProposition: Proposition | null;

  // Actions
  setCurrentSession: (sessionId: string, proposition: Proposition) => void;
  clearSession: () => void;
}

export const useDebateStore = create<DebateState>()(
  devtools(
    persist(
      (set) => ({
        currentSessionId: null,
        currentProposition: null,

        setCurrentSession: (sessionId, proposition) => {
          set({
            currentSessionId: sessionId,
            currentProposition: proposition,
          });
        },

        clearSession: () => {
          set({
            currentSessionId: null,
            currentProposition: null,
          });
        },
      }),
      {
        name: 'clearside-debate-store',
        partialize: (state) => ({
          // Don't persist session (for now)
          currentSessionId: null,
          currentProposition: null,
        }),
      }
    ),
    { name: 'DebateStore' }
  )
);
```

### Styling

```css
/* src/components/InputForm/InputForm.module.css */

.inputForm {
  max-width: 720px;
  margin: 0 auto;
  padding: 2rem;
}

.header {
  margin-bottom: 2.5rem;
  text-align: center;
}

.title {
  font-size: 2rem;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 0.75rem;
  line-height: 1.2;
}

.description {
  font-size: 1.125rem;
  color: var(--color-text-secondary);
  line-height: 1.5;
}

.field {
  margin-bottom: 2rem;
}

.optional {
  font-weight: 400;
  color: var(--color-text-tertiary);
  font-size: 0.875rem;
}

.hasError {
  border-color: var(--color-error);
}

.charCount {
  margin-top: 0.5rem;
}

.helpText {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: var(--color-text-tertiary);
}

.apiError {
  margin-bottom: 1.5rem;
}

.actions {
  margin-top: 2.5rem;
  display: flex;
  justify-content: center;
}

.submitButton {
  min-width: 200px;
}

.loadingMessage {
  margin-top: 1.5rem;
  text-align: center;
  color: var(--color-text-secondary);
}

.loadingSubtext {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: var(--color-text-tertiary);
}

/* Responsive */
@media (max-width: 768px) {
  .inputForm {
    padding: 1.5rem;
  }

  .title {
    font-size: 1.5rem;
  }

  .description {
    font-size: 1rem;
  }
}
```

---

## Testing Requirements

### Unit Tests

```typescript
// src/components/InputForm/InputForm.test.tsx

import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { InputForm } from './InputForm';
import { useDebateStore } from '@/stores/debateStore';
import { apiClient } from '@/lib/apiClient';

jest.mock('@/lib/apiClient');

const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;

function renderInputForm(props = {}) {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return render(
    <QueryClientProvider client={queryClient}>
      <InputForm {...props} />
    </QueryClientProvider>
  );
}

describe('InputForm', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    useDebateStore.getState().clearSession();
  });

  describe('Rendering', () => {
    it('renders form with question and context fields', () => {
      renderInputForm();

      expect(screen.getByLabelText(/your question/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/additional context/i)).toBeInTheDocument();
      expect(
        screen.getByRole('button', { name: /analyze question/i })
      ).toBeInTheDocument();
    });

    it('displays character counts for both fields', () => {
      renderInputForm();

      expect(screen.getByText('0 / 500')).toBeInTheDocument();
      expect(screen.getByText('0 / 5000')).toBeInTheDocument();
    });

    it('shows help text for both fields', () => {
      renderInputForm();

      expect(
        screen.getByText(/a clear, specific question/i)
      ).toBeInTheDocument();
      expect(
        screen.getByText(/background, constraints, or specific considerations/i)
      ).toBeInTheDocument();
    });
  });

  describe('Validation', () => {
    it('disables submit when question is empty', () => {
      renderInputForm();

      const submitButton = screen.getByRole('button', {
        name: /analyze question/i,
      });
      expect(submitButton).toBeDisabled();
    });

    it('shows error when question is too short', async () => {
      const user = userEvent.setup();
      renderInputForm();

      const questionInput = screen.getByLabelText(/your question/i);
      await user.type(questionInput, 'Short');
      await user.tab(); // Blur to trigger validation

      await waitFor(() => {
        expect(
          screen.getByText(/question must be at least 10 characters/i)
        ).toBeInTheDocument();
      });
    });

    it('shows error when question is too long', async () => {
      const user = userEvent.setup();
      renderInputForm();

      const questionInput = screen.getByLabelText(/your question/i);
      const longText = 'a'.repeat(501);
      await user.type(questionInput, longText);

      await waitFor(() => {
        expect(
          screen.getByText(/question must be no more than 500 characters/i)
        ).toBeInTheDocument();
      });
    });

    it('enables submit when question is valid', async () => {
      const user = userEvent.setup();
      renderInputForm();

      const questionInput = screen.getByLabelText(/your question/i);
      await user.type(
        questionInput,
        'Should we implement a moratorium on AI data centers?'
      );

      await waitFor(() => {
        const submitButton = screen.getByRole('button', {
          name: /analyze question/i,
        });
        expect(submitButton).not.toBeDisabled();
      });
    });
  });

  describe('Submission', () => {
    it('submits form with valid question', async () => {
      const user = userEvent.setup();
      const onSuccess = jest.fn();

      mockApiClient.post.mockResolvedValue({
        data: {
          sessionId: 'test-session-id',
          proposition: {
            normalized: 'Should we implement a moratorium on AI data centers?',
            original: 'Should we implement a moratorium on AI data centers?',
          },
        },
      });

      renderInputForm({ onSuccess });

      const questionInput = screen.getByLabelText(/your question/i);
      await user.type(
        questionInput,
        'Should we implement a moratorium on AI data centers?'
      );

      const submitButton = screen.getByRole('button', {
        name: /analyze question/i,
      });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockApiClient.post).toHaveBeenCalledWith(
          '/api/analyze',
          {
            question: 'Should we implement a moratorium on AI data centers?',
            context: undefined,
          },
          expect.any(Object)
        );
      });

      await waitFor(() => {
        expect(onSuccess).toHaveBeenCalledWith('test-session-id');
      });
    });

    it('shows loading state during submission', async () => {
      const user = userEvent.setup();

      mockApiClient.post.mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 1000))
      );

      renderInputForm();

      const questionInput = screen.getByLabelText(/your question/i);
      await user.type(
        questionInput,
        'Should we implement a moratorium on AI data centers?'
      );

      const submitButton = screen.getByRole('button', {
        name: /analyze question/i,
      });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/analyzing/i)).toBeInTheDocument();
      });
    });

    it('handles API errors gracefully', async () => {
      const user = userEvent.setup();
      const onError = jest.fn();

      mockApiClient.post.mockRejectedValue(new Error('API Error'));

      renderInputForm({ onError });

      const questionInput = screen.getByLabelText(/your question/i);
      await user.type(
        questionInput,
        'Should we implement a moratorium on AI data centers?'
      );

      const submitButton = screen.getByRole('button', {
        name: /analyze question/i,
      });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/analysis failed/i)).toBeInTheDocument();
      });

      expect(onError).toHaveBeenCalledWith(expect.any(Error));
    });
  });

  describe('Paste Behavior', () => {
    it('suggests context field for long paste', async () => {
      const user = userEvent.setup();
      global.confirm = jest.fn(() => true);

      renderInputForm();

      const questionInput = screen.getByLabelText(/your question/i);
      const longText = 'a'.repeat(300);

      await user.click(questionInput);
      await user.paste(longText);

      expect(global.confirm).toHaveBeenCalled();

      const contextInput = screen.getByLabelText(/additional context/i);
      expect(contextInput).toHaveValue(longText);
    });
  });
});
```

---

## Implementation Steps

1. **Set up component structure** (Day 1, Morning)
   - Create component file and module CSS
   - Set up TypeScript interfaces
   - Implement basic JSX structure

2. **Implement form state management** (Day 1, Afternoon)
   - Add local state with useState
   - Implement change handlers
   - Add validation logic

3. **Integrate Zustand store** (Day 2, Morning)
   - Connect to global debate store
   - Handle session management
   - Test state persistence

4. **Implement API integration** (Day 2, Afternoon)
   - Create mutation hook
   - Handle loading states
   - Handle error states

5. **Add accessibility features** (Day 3, Morning)
   - ARIA labels and descriptions
   - Keyboard navigation
   - Screen reader testing

6. **Write tests** (Day 3, Afternoon)
   - Unit tests for validation
   - Integration tests for submission
   - Accessibility tests

---

## Dependencies

### NPM Packages
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "zustand": "^4.4.0",
    "@tanstack/react-query": "^5.0.0"
  },
  "devDependencies": {
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0"
  }
}
```

### Related Tasks
- **AGENT-001:** Orchestrator processes the question input
- **UI-002:** Results display shows the analyzed output
- **TEST-001:** Unit tests for UI components

---

## Validation Steps

- [ ] Form renders correctly on all screen sizes
- [ ] Validation errors display appropriately
- [ ] Submit button states work correctly
- [ ] Loading states are clear and visible
- [ ] Error handling works for API failures
- [ ] Accessibility audit passes (axe DevTools)
- [ ] Character counts update in real-time
- [ ] Paste detection works for long text
- [ ] Store integration persists correctly
- [ ] All unit tests pass

---

## Notes

- Keep the UI minimal and focused (no chatbot aesthetic)
- Ensure professional tone in all messaging
- Loading states should set proper expectations (20-30s)
- Consider adding "Example Questions" for first-time users
- Future: Add question templates/presets
- Future: Support saving draft questions locally

---

**Last Updated:** 2025-12-23
**Owner:** Frontend Team
**Reviewer:** Product Lead
