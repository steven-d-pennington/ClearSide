# UI-002: Streaming Results Display Component

**Task ID:** UI-002
**Phase:** Phase 1 - MVP
**Category:** UI
**Priority:** P0 (Critical - MVP Core)
**Estimated Effort:** 4-5 days
**Dependencies:** UI-001 (Input Form), AGENT-001 through AGENT-004
**Status:** TO DO

---

## Overview

Create the streaming results display component that shows the debate analysis as it's generated in real-time using Server-Sent Events (SSE). This component progressively renders the proposition, pro arguments, con arguments, and moderator synthesis as they stream from the backend.

### Related Documentation
- **Product Vision:** `docs/01_product-vision.md`
- **Requirements:** `docs/REQUIREMENTS.md` - User Story US-002
- **JSON Schema:** `docs/04_json-schema.md` - Output structure
- **Kanban:** `docs/KANBAN.md` - Task UI-002

---

## Objectives

1. **Implement SSE streaming** for real-time debate generation
2. **Progressive rendering** of each section as it arrives
3. **Visual hierarchy** that separates Pro/Con/Moderator clearly
4. **Skeleton loading states** for sections not yet received
5. **Error recovery** for connection failures
6. **Smooth animations** for content appearing
7. **Mobile-responsive layout** for all screen sizes

---

## Acceptance Criteria

### Functional Requirements

- [ ] Connects to SSE endpoint on component mount
- [ ] Displays proposition section first
- [ ] Streams Pro arguments with progressive rendering
- [ ] Streams Con arguments with progressive rendering
- [ ] Streams Moderator synthesis last
- [ ] Shows loading skeleton for pending sections
- [ ] Handles connection errors gracefully
- [ ] Supports reconnection on disconnect
- [ ] Displays timestamps for each section
- [ ] Allows scrolling during streaming

### Non-Functional Requirements

- [ ] Streaming feels smooth and responsive
- [ ] No janky layout shifts during updates
- [ ] Works on slow connections (3G)
- [ ] Handles large debates (100+ arguments)
- [ ] Memory efficient (no leaks)
- [ ] Accessible to screen readers

### Design Requirements

- [ ] Clear visual separation between Pro/Con
- [ ] Professional, non-partisan tone
- [ ] Moderator section is visually distinct
- [ ] Typography emphasizes clarity
- [ ] Color coding is subtle (not red/blue)
- [ ] Loading states are non-intrusive

---

## Technical Specification

### Component Architecture

```typescript
// src/components/ResultsDisplay/ResultsDisplay.tsx

import React, { useEffect, useState, useRef, useCallback } from 'react';
import { useSSEConnection } from '@/hooks/useSSEConnection';
import { useDebateStore } from '@/stores/debateStore';
import { DebateOutput } from '@/types/debate';
import { PropositionSection } from './sections/PropositionSection';
import { ProSection } from './sections/ProSection';
import { ConSection } from './sections/ConSection';
import { ModeratorSection } from './sections/ModeratorSection';
import { StreamingIndicator } from './StreamingIndicator';
import { SkeletonLoader } from '@/components/ui/SkeletonLoader';
import { Alert } from '@/components/ui/Alert';
import { Button } from '@/components/ui/Button';
import styles from './ResultsDisplay.module.css';

interface ResultsDisplayProps {
  sessionId: string;
  onComplete?: (output: DebateOutput) => void;
  onError?: (error: Error) => void;
}

type StreamingState = 'connecting' | 'streaming' | 'complete' | 'error';

interface StreamingProgress {
  proposition: boolean;
  pro: boolean;
  con: boolean;
  moderator: boolean;
}

export const ResultsDisplay: React.FC<ResultsDisplayProps> = ({
  sessionId,
  onComplete,
  onError,
}) => {
  // Debate output state
  const [output, setOutput] = useState<Partial<DebateOutput>>({});
  const [streamingState, setStreamingState] = useState<StreamingState>('connecting');
  const [progress, setProgress] = useState<StreamingProgress>({
    proposition: false,
    pro: false,
    con: false,
    moderator: false,
  });

  // Refs
  const containerRef = useRef<HTMLDivElement>(null);
  const autoScrollEnabled = useRef(true);

  // SSE connection
  const {
    connect,
    disconnect,
    isConnected,
    error: sseError,
    retry,
  } = useSSEConnection({
    onMessage: handleSSEMessage,
    onError: handleSSEError,
    onComplete: handleSSEComplete,
  });

  /**
   * Handle incoming SSE messages
   */
  function handleSSEMessage(event: MessageEvent) {
    try {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'proposition':
          setOutput((prev) => ({
            ...prev,
            proposition: data.payload,
          }));
          setProgress((prev) => ({ ...prev, proposition: true }));
          setStreamingState('streaming');
          break;

        case 'pro':
          setOutput((prev) => ({
            ...prev,
            pro: data.payload,
          }));
          setProgress((prev) => ({ ...prev, pro: true }));
          break;

        case 'con':
          setOutput((prev) => ({
            ...prev,
            con: data.payload,
          }));
          setProgress((prev) => ({ ...prev, con: true }));
          break;

        case 'moderator':
          setOutput((prev) => ({
            ...prev,
            moderator: data.payload,
          }));
          setProgress((prev) => ({ ...prev, moderator: true }));
          break;

        case 'meta':
          setOutput((prev) => ({
            ...prev,
            meta: data.payload,
          }));
          break;

        default:
          console.warn('Unknown SSE message type:', data.type);
      }

      // Auto-scroll to bottom if enabled
      if (autoScrollEnabled.current) {
        scrollToBottom();
      }
    } catch (err) {
      console.error('Failed to parse SSE message:', err);
    }
  }

  /**
   * Handle SSE errors
   */
  function handleSSEError(error: Error) {
    console.error('SSE connection error:', error);
    setStreamingState('error');
    onError?.(error);
  }

  /**
   * Handle SSE completion
   */
  function handleSSEComplete(finalOutput: DebateOutput) {
    setOutput(finalOutput);
    setStreamingState('complete');
    setProgress({
      proposition: true,
      pro: true,
      con: true,
      moderator: true,
    });
    onComplete?.(finalOutput);
  }

  /**
   * Scroll to bottom of container
   */
  const scrollToBottom = useCallback(() => {
    if (containerRef.current) {
      containerRef.current.scrollTo({
        top: containerRef.current.scrollHeight,
        behavior: 'smooth',
      });
    }
  }, []);

  /**
   * Detect manual scrolling
   */
  const handleScroll = useCallback(() => {
    if (!containerRef.current) return;

    const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;

    // Disable auto-scroll if user scrolls up
    autoScrollEnabled.current = distanceFromBottom < 100;
  }, []);

  /**
   * Connect to SSE on mount
   */
  useEffect(() => {
    const url = `/api/analyze/${sessionId}/stream`;
    connect(url);

    return () => {
      disconnect();
    };
  }, [sessionId, connect, disconnect]);

  /**
   * Retry connection
   */
  const handleRetry = useCallback(() => {
    setStreamingState('connecting');
    const url = `/api/analyze/${sessionId}/stream`;
    retry(url);
  }, [sessionId, retry]);

  return (
    <div
      ref={containerRef}
      className={styles.resultsDisplay}
      onScroll={handleScroll}
    >
      {/* Header */}
      <div className={styles.header}>
        <h2 className={styles.title}>Analysis Results</h2>
        {streamingState === 'streaming' && (
          <StreamingIndicator className={styles.indicator} />
        )}
      </div>

      {/* Connection Error */}
      {streamingState === 'error' && (
        <Alert variant="error" className={styles.errorAlert}>
          <strong>Connection lost</strong>
          <p>
            {sseError?.message ||
              'Failed to connect to analysis stream. Please try again.'}
          </p>
          <Button onClick={handleRetry} variant="secondary" size="sm">
            Retry Connection
          </Button>
        </Alert>
      )}

      {/* Proposition Section */}
      {output.proposition ? (
        <PropositionSection data={output.proposition} />
      ) : (
        <SkeletonLoader variant="proposition" />
      )}

      {/* Pro Section */}
      {output.pro ? (
        <ProSection data={output.pro} />
      ) : progress.proposition ? (
        <SkeletonLoader variant="arguments" title="Arguments FOR" />
      ) : null}

      {/* Con Section */}
      {output.con ? (
        <ConSection data={output.con} />
      ) : progress.pro ? (
        <SkeletonLoader variant="arguments" title="Arguments AGAINST" />
      ) : null}

      {/* Moderator Section */}
      {output.moderator ? (
        <ModeratorSection data={output.moderator} />
      ) : progress.con ? (
        <SkeletonLoader variant="synthesis" title="Moderator Synthesis" />
      ) : null}

      {/* Completion Message */}
      {streamingState === 'complete' && (
        <div className={styles.completionMessage}>
          <p>Analysis complete. Review the arguments and synthesis above.</p>
        </div>
      )}
    </div>
  );
};
```

### SSE Connection Hook

```typescript
// src/hooks/useSSEConnection.ts

import { useCallback, useRef, useState } from 'react';

interface UseSSEConnectionOptions {
  onMessage: (event: MessageEvent) => void;
  onError: (error: Error) => void;
  onComplete: (output: any) => void;
  reconnectAttempts?: number;
  reconnectDelay?: number;
}

interface UseSSEConnectionReturn {
  connect: (url: string) => void;
  disconnect: () => void;
  retry: (url: string) => void;
  isConnected: boolean;
  error: Error | null;
}

export function useSSEConnection({
  onMessage,
  onError,
  onComplete,
  reconnectAttempts = 3,
  reconnectDelay = 2000,
}: UseSSEConnectionOptions): UseSSEConnectionReturn {
  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectCountRef = useRef(0);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  /**
   * Connect to SSE endpoint
   */
  const connect = useCallback(
    (url: string) => {
      // Close existing connection
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }

      try {
        const eventSource = new EventSource(url);
        eventSourceRef.current = eventSource;

        eventSource.onopen = () => {
          console.log('SSE connection opened');
          setIsConnected(true);
          setError(null);
          reconnectCountRef.current = 0;
        };

        eventSource.onmessage = (event) => {
          onMessage(event);
        };

        eventSource.addEventListener('complete', (event) => {
          const data = JSON.parse((event as MessageEvent).data);
          onComplete(data);
          eventSource.close();
          setIsConnected(false);
        });

        eventSource.onerror = (event) => {
          console.error('SSE connection error:', event);
          eventSource.close();
          setIsConnected(false);

          const err = new Error('SSE connection failed');
          setError(err);
          onError(err);

          // Attempt reconnection
          if (reconnectCountRef.current < reconnectAttempts) {
            reconnectCountRef.current++;
            reconnectTimeoutRef.current = setTimeout(() => {
              console.log(
                `Reconnecting... Attempt ${reconnectCountRef.current}`
              );
              connect(url);
            }, reconnectDelay);
          }
        };
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown error');
        setError(error);
        onError(error);
      }
    },
    [onMessage, onError, onComplete, reconnectAttempts, reconnectDelay]
  );

  /**
   * Disconnect from SSE
   */
  const disconnect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }

    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }

    setIsConnected(false);
  }, []);

  /**
   * Retry connection
   */
  const retry = useCallback(
    (url: string) => {
      reconnectCountRef.current = 0;
      setError(null);
      connect(url);
    },
    [connect]
  );

  return {
    connect,
    disconnect,
    retry,
    isConnected,
    error,
  };
}
```

### Section Components

```typescript
// src/components/ResultsDisplay/sections/ProSection.tsx

import React from 'react';
import { ProArguments } from '@/types/debate';
import { ArgumentCard } from '../ArgumentCard';
import { AssumptionsList } from '../AssumptionsList';
import { UncertaintiesList } from '../UncertaintiesList';
import styles from './ProSection.module.css';

interface ProSectionProps {
  data: ProArguments;
}

export const ProSection: React.FC<ProSectionProps> = ({ data }) => {
  return (
    <section className={styles.proSection} aria-labelledby="pro-heading">
      <header className={styles.header}>
        <h3 id="pro-heading" className={styles.heading}>
          Arguments FOR
        </h3>
        <p className={styles.description}>
          Steel-man arguments supporting the proposition
        </p>
      </header>

      {/* Summary */}
      {data.summary && (
        <div className={styles.summary}>
          <h4>Summary</h4>
          <p>{data.summary}</p>
        </div>
      )}

      {/* Arguments */}
      <div className={styles.arguments}>
        {data.arguments.map((argument, index) => (
          <ArgumentCard
            key={index}
            argument={argument}
            index={index}
            side="pro"
          />
        ))}
      </div>

      {/* Assumptions */}
      {data.assumptions && data.assumptions.length > 0 && (
        <AssumptionsList assumptions={data.assumptions} side="pro" />
      )}

      {/* Uncertainties */}
      {data.uncertainties && data.uncertainties.length > 0 && (
        <UncertaintiesList uncertainties={data.uncertainties} side="pro" />
      )}
    </section>
  );
};
```

```typescript
// src/components/ResultsDisplay/ArgumentCard.tsx

import React from 'react';
import { Argument } from '@/types/debate';
import { Badge } from '@/components/ui/Badge';
import { EvidenceTag } from './EvidenceTag';
import styles from './ArgumentCard.module.css';

interface ArgumentCardProps {
  argument: Argument;
  index: number;
  side: 'pro' | 'con';
}

export const ArgumentCard: React.FC<ArgumentCardProps> = ({
  argument,
  index,
  side,
}) => {
  return (
    <article className={`${styles.card} ${styles[side]}`}>
      <header className={styles.header}>
        <span className={styles.number}>{index + 1}</span>
        <h5 className={styles.title}>{argument.title}</h5>
        <Badge variant={argument.category}>{argument.category}</Badge>
      </header>

      <p className={styles.description}>{argument.description}</p>

      {/* Evidence */}
      {argument.evidence && argument.evidence.length > 0 && (
        <div className={styles.evidence}>
          <h6>Evidence</h6>
          <ul>
            {argument.evidence.map((item, i) => (
              <li key={i}>
                <EvidenceTag type={item.type} />
                <span>{item.claim}</span>
                {item.confidence && (
                  <Badge variant="confidence" size="sm">
                    {item.confidence}
                  </Badge>
                )}
              </li>
            ))}
          </ul>
        </div>
      )}

      {/* Assumptions */}
      {argument.assumptions && argument.assumptions.length > 0 && (
        <div className={styles.assumptions}>
          <h6>Key Assumptions</h6>
          <ul>
            {argument.assumptions.map((assumption, i) => (
              <li key={i}>{assumption}</li>
            ))}
          </ul>
        </div>
      )}
    </article>
  );
};
```

### Streaming Indicator

```typescript
// src/components/ResultsDisplay/StreamingIndicator.tsx

import React from 'react';
import styles from './StreamingIndicator.module.css';

interface StreamingIndicatorProps {
  className?: string;
}

export const StreamingIndicator: React.FC<StreamingIndicatorProps> = ({
  className = '',
}) => {
  return (
    <div className={`${styles.indicator} ${className}`}>
      <div className={styles.dot} />
      <div className={styles.dot} />
      <div className={styles.dot} />
      <span className={styles.text}>Analyzing...</span>
    </div>
  );
};
```

### Styling

```css
/* src/components/ResultsDisplay/ResultsDisplay.module.css */

.resultsDisplay {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  overflow-y: auto;
  max-height: calc(100vh - 120px);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  padding-bottom: 1rem;
  border-bottom: 2px solid var(--color-border);
}

.title {
  font-size: 1.75rem;
  font-weight: 600;
  color: var(--color-text-primary);
}

.indicator {
  margin-left: 1rem;
}

.errorAlert {
  margin-bottom: 2rem;
}

.completionMessage {
  margin-top: 3rem;
  padding: 1.5rem;
  background: var(--color-success-bg);
  border-left: 4px solid var(--color-success);
  border-radius: 4px;
  text-align: center;
  color: var(--color-text-secondary);
}

/* Responsive */
@media (max-width: 768px) {
  .resultsDisplay {
    padding: 1rem;
  }

  .header {
    flex-direction: column;
    align-items: flex-start;
  }

  .title {
    font-size: 1.5rem;
  }
}
```

```css
/* src/components/ResultsDisplay/sections/ProSection.module.css */

.proSection {
  margin-bottom: 3rem;
  padding: 2rem;
  background: var(--color-pro-bg);
  border-left: 4px solid var(--color-pro);
  border-radius: 8px;
}

.header {
  margin-bottom: 1.5rem;
}

.heading {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--color-pro-dark);
  margin-bottom: 0.5rem;
}

.description {
  color: var(--color-text-secondary);
  font-size: 0.95rem;
}

.summary {
  margin-bottom: 2rem;
  padding: 1rem;
  background: var(--color-bg-light);
  border-radius: 4px;
}

.summary h4 {
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
  color: var(--color-text-primary);
}

.arguments {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}
```

---

## Testing Requirements

```typescript
// src/components/ResultsDisplay/ResultsDisplay.test.tsx

import { render, screen, waitFor } from '@testing-library/react';
import { ResultsDisplay } from './ResultsDisplay';
import { setupSSEMock } from '@/test-utils/sseMock';

describe('ResultsDisplay', () => {
  beforeEach(() => {
    setupSSEMock();
  });

  it('renders loading state initially', () => {
    render(<ResultsDisplay sessionId="test-session" />);

    expect(screen.getByText(/analysis results/i)).toBeInTheDocument();
  });

  it('displays proposition first', async () => {
    const { emitSSE } = setupSSEMock();
    render(<ResultsDisplay sessionId="test-session" />);

    emitSSE('proposition', {
      normalized: 'Should we implement a moratorium?',
      original: 'Should we implement a moratorium?',
    });

    await waitFor(() => {
      expect(
        screen.getByText('Should we implement a moratorium?')
      ).toBeInTheDocument();
    });
  });

  it('streams all sections progressively', async () => {
    const { emitSSE } = setupSSEMock();
    render(<ResultsDisplay sessionId="test-session" />);

    // Emit proposition
    emitSSE('proposition', { normalized: 'Test proposition' });

    await waitFor(() => {
      expect(screen.getByText('Test proposition')).toBeInTheDocument();
    });

    // Emit pro arguments
    emitSSE('pro', {
      arguments: [{ title: 'Pro Argument 1', description: 'Pro desc' }],
    });

    await waitFor(() => {
      expect(screen.getByText('Pro Argument 1')).toBeInTheDocument();
    });
  });

  it('handles connection errors', async () => {
    const { triggerError } = setupSSEMock();
    const onError = jest.fn();

    render(<ResultsDisplay sessionId="test-session" onError={onError} />);

    triggerError(new Error('Connection failed'));

    await waitFor(() => {
      expect(screen.getByText(/connection lost/i)).toBeInTheDocument();
    });

    expect(onError).toHaveBeenCalled();
  });

  it('calls onComplete when streaming finishes', async () => {
    const { emitComplete } = setupSSEMock();
    const onComplete = jest.fn();

    render(<ResultsDisplay sessionId="test-session" onComplete={onComplete} />);

    const fullOutput = {
      proposition: {},
      pro: {},
      con: {},
      moderator: {},
    };

    emitComplete(fullOutput);

    await waitFor(() => {
      expect(onComplete).toHaveBeenCalledWith(fullOutput);
    });
  });
});
```

---

## Implementation Steps

1. **Day 1:** Set up component structure and SSE hook
2. **Day 2:** Implement progressive rendering for each section
3. **Day 3:** Add loading skeletons and error handling
4. **Day 4:** Style components with responsive design
5. **Day 5:** Write comprehensive tests and accessibility audit

---

## Dependencies

- EventSource API (browser native)
- React 18.2+
- TypeScript 5.0+
- CSS Modules

---

## Validation Steps

- [ ] SSE connection establishes successfully
- [ ] All sections stream progressively
- [ ] Loading states display appropriately
- [ ] Error recovery works
- [ ] Mobile responsive
- [ ] Accessibility audit passes
- [ ] All tests pass

---

**Last Updated:** 2025-12-23
