# UI-003: Interactive Timeline Component

**Task ID:** UI-003
**Phase:** Phase 1 - MVP
**Category:** UI
**Priority:** P1 (High - Enhanced UX)
**Estimated Effort:** 3 days
**Dependencies:** UI-002 (Results Display)
**Status:** TO DO

---

## Overview

Create an interactive timeline component that visualizes the debate generation process and allows users to scrub through the analysis stages. This provides transparency into the AI reasoning process and enables users to jump to specific sections.

### Related Documentation
- **Requirements:** `docs/REQUIREMENTS.md` - User Story US-003
- **Product Vision:** `docs/01_product-vision.md` - Transparency principle
- **Kanban:** `docs/KANBAN.md` - Task UI-003

---

## Objectives

1. **Visual timeline** showing analysis stages (Proposition â†’ Pro â†’ Con â†’ Moderator)
2. **Interactive scrubber** for seeking to specific sections
3. **Progress indicator** during streaming
4. **Timestamp display** for each completed stage
5. **Keyboard navigation** support
6. **Mobile-friendly** touch interaction

---

## Acceptance Criteria

### Functional Requirements

- [ ] Timeline displays 4 stages: Proposition, Pro, Con, Moderator
- [ ] Progress bar fills as analysis completes
- [ ] Clicking a stage scrolls to that section
- [ ] Active stage is highlighted
- [ ] Incomplete stages are visually disabled
- [ ] Timestamps show completion time for each stage
- [ ] Keyboard arrow keys navigate between stages
- [ ] Touch gestures work on mobile

### Non-Functional Requirements

- [ ] Timeline is always visible (sticky/fixed)
- [ ] Animations are smooth (60fps)
- [ ] Works on all screen sizes
- [ ] Accessible via keyboard and screen reader

### Design Requirements

- [ ] Minimalist design (doesn't compete with content)
- [ ] Clear visual hierarchy
- [ ] Professional color palette
- [ ] Responsive typography

---

## Technical Specification

### Component Implementation

```typescript
// src/components/Timeline/Timeline.tsx

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useDebateProgress } from '@/hooks/useDebateProgress';
import { TimelineStage } from './TimelineStage';
import { ProgressBar } from './ProgressBar';
import styles from './Timeline.module.css';

type Stage = 'proposition' | 'pro' | 'con' | 'moderator';

interface StageInfo {
  id: Stage;
  label: string;
  icon: string;
  order: number;
}

const STAGES: StageInfo[] = [
  { id: 'proposition', label: 'Proposition', icon: 'ðŸ“‹', order: 0 },
  { id: 'pro', label: 'Arguments FOR', icon: 'âœ…', order: 1 },
  { id: 'con', label: 'Arguments AGAINST', icon: 'âŒ', order: 2 },
  { id: 'moderator', label: 'Synthesis', icon: 'âš–ï¸', order: 3 },
];

interface TimelineProps {
  sessionId: string;
  onStageSelect?: (stage: Stage) => void;
  className?: string;
}

export const Timeline: React.FC<TimelineProps> = ({
  sessionId,
  onStageSelect,
  className = '',
}) => {
  const [activeStage, setActiveStage] = useState<Stage>('proposition');
  const timelineRef = useRef<HTMLDivElement>(null);

  // Get progress from hook
  const { progress, completedStages, currentStage, timestamps } =
    useDebateProgress(sessionId);

  /**
   * Handle stage click
   */
  const handleStageClick = useCallback(
    (stage: Stage) => {
      // Only allow clicking completed stages
      if (!completedStages.includes(stage)) {
        return;
      }

      setActiveStage(stage);
      onStageSelect?.(stage);

      // Scroll to section
      const sectionId = `section-${stage}`;
      const element = document.getElementById(sectionId);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    },
    [completedStages, onStageSelect]
  );

  /**
   * Handle keyboard navigation
   */
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      const currentIndex = STAGES.findIndex((s) => s.id === activeStage);

      if (e.key === 'ArrowRight') {
        e.preventDefault();
        const nextIndex = Math.min(currentIndex + 1, STAGES.length - 1);
        const nextStage = STAGES[nextIndex];
        if (completedStages.includes(nextStage.id)) {
          handleStageClick(nextStage.id);
        }
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        const prevIndex = Math.max(currentIndex - 1, 0);
        const prevStage = STAGES[prevIndex];
        if (completedStages.includes(prevStage.id)) {
          handleStageClick(prevStage.id);
        }
      }
    },
    [activeStage, completedStages, handleStageClick]
  );

  /**
   * Update active stage based on current progress
   */
  useEffect(() => {
    if (currentStage) {
      setActiveStage(currentStage);
    }
  }, [currentStage]);

  return (
    <nav
      ref={timelineRef}
      className={`${styles.timeline} ${className}`}
      aria-label="Analysis timeline"
      onKeyDown={handleKeyDown}
      tabIndex={0}
    >
      {/* Progress Bar */}
      <ProgressBar progress={progress} className={styles.progressBar} />

      {/* Stages */}
      <ol className={styles.stages}>
        {STAGES.map((stage) => (
          <TimelineStage
            key={stage.id}
            stage={stage}
            isActive={activeStage === stage.id}
            isComplete={completedStages.includes(stage.id)}
            isCurrent={currentStage === stage.id}
            timestamp={timestamps[stage.id]}
            onClick={() => handleStageClick(stage.id)}
          />
        ))}
      </ol>

      {/* Mobile Indicator */}
      <div className={styles.mobileIndicator}>
        <span className={styles.currentStageLabel}>
          {STAGES.find((s) => s.id === currentStage)?.label || 'Starting...'}
        </span>
        <span className={styles.progressText}>{Math.round(progress)}%</span>
      </div>
    </nav>
  );
};
```

### Timeline Stage Component

```typescript
// src/components/Timeline/TimelineStage.tsx

import React from 'react';
import { formatTimestamp } from '@/utils/date';
import styles from './TimelineStage.module.css';

interface TimelineStageProps {
  stage: {
    id: string;
    label: string;
    icon: string;
    order: number;
  };
  isActive: boolean;
  isComplete: boolean;
  isCurrent: boolean;
  timestamp?: number;
  onClick: () => void;
}

export const TimelineStage: React.FC<TimelineStageProps> = ({
  stage,
  isActive,
  isComplete,
  isCurrent,
  timestamp,
  onClick,
}) => {
  const classNames = [
    styles.stage,
    isActive && styles.active,
    isComplete && styles.complete,
    isCurrent && styles.current,
    !isComplete && styles.disabled,
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <li className={classNames}>
      <button
        onClick={onClick}
        disabled={!isComplete}
        aria-current={isActive ? 'step' : undefined}
        aria-label={`${stage.label}${isComplete ? ' - completed' : ' - in progress'}`}
        className={styles.button}
      >
        {/* Icon */}
        <span className={styles.icon} aria-hidden="true">
          {isCurrent && !isComplete ? (
            <span className={styles.spinner} />
          ) : (
            stage.icon
          )}
        </span>

        {/* Label */}
        <span className={styles.label}>{stage.label}</span>

        {/* Timestamp */}
        {timestamp && (
          <span className={styles.timestamp}>
            {formatTimestamp(timestamp)}
          </span>
        )}

        {/* Connector Line */}
        {stage.order < 3 && <span className={styles.connector} />}
      </button>
    </li>
  );
};
```

### Progress Bar Component

```typescript
// src/components/Timeline/ProgressBar.tsx

import React from 'react';
import styles from './ProgressBar.module.css';

interface ProgressBarProps {
  progress: number; // 0-100
  className?: string;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({
  progress,
  className = '',
}) => {
  return (
    <div className={`${styles.progressBar} ${className}`} role="progressbar" aria-valuenow={progress} aria-valuemin={0} aria-valuemax={100}>
      <div
        className={styles.fill}
        style={{ width: `${Math.min(100, Math.max(0, progress))}%` }}
      />
    </div>
  );
};
```

### Progress Hook

```typescript
// src/hooks/useDebateProgress.ts

import { useState, useEffect } from 'react';
import { useDebateStore } from '@/stores/debateStore';

type Stage = 'proposition' | 'pro' | 'con' | 'moderator';

interface DebateProgress {
  progress: number; // 0-100
  completedStages: Stage[];
  currentStage: Stage | null;
  timestamps: Record<Stage, number>;
}

export function useDebateProgress(sessionId: string): DebateProgress {
  const [progress, setProgress] = useState(0);
  const [completedStages, setCompletedStages] = useState<Stage[]>([]);
  const [currentStage, setCurrentStage] = useState<Stage | null>(null);
  const [timestamps, setTimestamps] = useState<Record<Stage, number>>({} as Record<Stage, number>);

  const debateOutput = useDebateStore((state) => state.currentOutput);

  useEffect(() => {
    if (!debateOutput) return;

    const stages: Stage[] = [];
    const times: Record<Stage, number> = {} as Record<Stage, number>;
    let progressPercent = 0;

    if (debateOutput.proposition) {
      stages.push('proposition');
      times.proposition = Date.now();
      progressPercent = 25;
      setCurrentStage('pro');
    }

    if (debateOutput.pro) {
      stages.push('pro');
      times.pro = Date.now();
      progressPercent = 50;
      setCurrentStage('con');
    }

    if (debateOutput.con) {
      stages.push('con');
      times.con = Date.now();
      progressPercent = 75;
      setCurrentStage('moderator');
    }

    if (debateOutput.moderator) {
      stages.push('moderator');
      times.moderator = Date.now();
      progressPercent = 100;
      setCurrentStage(null);
    }

    setCompletedStages(stages);
    setTimestamps(times);
    setProgress(progressPercent);
  }, [debateOutput]);

  return {
    progress,
    completedStages,
    currentStage,
    timestamps,
  };
}
```

### Styling

```css
/* src/components/Timeline/Timeline.module.css */

.timeline {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--color-bg-primary);
  border-bottom: 1px solid var(--color-border);
  padding: 1rem 2rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.progressBar {
  margin-bottom: 1rem;
}

.stages {
  display: flex;
  justify-content: space-between;
  list-style: none;
  padding: 0;
  margin: 0;
  gap: 1rem;
}

.mobileIndicator {
  display: none;
}

/* Mobile */
@media (max-width: 768px) {
  .timeline {
    padding: 1rem;
  }

  .stages {
    display: none;
  }

  .mobileIndicator {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 0.5rem;
  }

  .currentStageLabel {
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .progressText {
    font-size: 0.875rem;
    color: var(--color-text-secondary);
  }
}
```

```css
/* src/components/Timeline/TimelineStage.module.css */

.stage {
  flex: 1;
  position: relative;
}

.button {
  width: 100%;
  padding: 0.75rem;
  background: none;
  border: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  transition: all 0.2s ease;
  border-radius: 8px;
}

.button:hover:not(:disabled) {
  background: var(--color-bg-hover);
}

.button:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.icon {
  font-size: 1.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--color-bg-secondary);
  border: 2px solid var(--color-border);
  transition: all 0.3s ease;
}

.complete .icon {
  background: var(--color-success-bg);
  border-color: var(--color-success);
}

.active .icon {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 4px var(--color-primary-alpha);
}

.current .icon {
  border-color: var(--color-primary);
  animation: pulse 2s infinite;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--color-border);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 0 0 var(--color-primary-alpha);
  }
  50% {
    box-shadow: 0 0 0 8px transparent;
  }
}

.label {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--color-text-secondary);
  text-align: center;
}

.complete .label {
  color: var(--color-text-primary);
}

.active .label {
  color: var(--color-primary);
  font-weight: 600;
}

.timestamp {
  font-size: 0.75rem;
  color: var(--color-text-tertiary);
}

.connector {
  position: absolute;
  top: 24px;
  left: 50%;
  width: 100%;
  height: 2px;
  background: var(--color-border);
  z-index: -1;
}

.complete .connector {
  background: var(--color-success);
}
```

---

## Testing Requirements

```typescript
// src/components/Timeline/Timeline.test.tsx

import { render, screen, fireEvent } from '@testing-library/react';
import { Timeline } from './Timeline';
import { useDebateProgress } from '@/hooks/useDebateProgress';

jest.mock('@/hooks/useDebateProgress');

describe('Timeline', () => {
  it('renders all stages', () => {
    (useDebateProgress as jest.Mock).mockReturnValue({
      progress: 0,
      completedStages: [],
      currentStage: null,
      timestamps: {},
    });

    render(<Timeline sessionId="test" />);

    expect(screen.getByText('Proposition')).toBeInTheDocument();
    expect(screen.getByText('Arguments FOR')).toBeInTheDocument();
    expect(screen.getByText('Arguments AGAINST')).toBeInTheDocument();
    expect(screen.getByText('Synthesis')).toBeInTheDocument();
  });

  it('shows progress correctly', () => {
    (useDebateProgress as jest.Mock).mockReturnValue({
      progress: 50,
      completedStages: ['proposition', 'pro'],
      currentStage: 'con',
      timestamps: {},
    });

    render(<Timeline sessionId="test" />);

    const progressBar = screen.getByRole('progressbar');
    expect(progressBar).toHaveAttribute('aria-valuenow', '50');
  });

  it('allows clicking completed stages', () => {
    const onStageSelect = jest.fn();

    (useDebateProgress as jest.Mock).mockReturnValue({
      progress: 50,
      completedStages: ['proposition', 'pro'],
      currentStage: 'con',
      timestamps: {},
    });

    render(<Timeline sessionId="test" onStageSelect={onStageSelect} />);

    const proButton = screen.getByRole('button', { name: /arguments for/i });
    fireEvent.click(proButton);

    expect(onStageSelect).toHaveBeenCalledWith('pro');
  });

  it('disables incomplete stages', () => {
    (useDebateProgress as jest.Mock).mockReturnValue({
      progress: 25,
      completedStages: ['proposition'],
      currentStage: 'pro',
      timestamps: {},
    });

    render(<Timeline sessionId="test" />);

    const conButton = screen.getByRole('button', { name: /arguments against/i });
    expect(conButton).toBeDisabled();
  });

  it('supports keyboard navigation', () => {
    const onStageSelect = jest.fn();

    (useDebateProgress as jest.Mock).mockReturnValue({
      progress: 50,
      completedStages: ['proposition', 'pro'],
      currentStage: 'con',
      timestamps: {},
    });

    render(<Timeline sessionId="test" onStageSelect={onStageSelect} />);

    const timeline = screen.getByRole('navigation');
    fireEvent.keyDown(timeline, { key: 'ArrowRight' });

    expect(onStageSelect).toHaveBeenCalledWith('pro');
  });
});
```

---

## Implementation Steps

1. **Day 1:** Build Timeline and TimelineStage components
2. **Day 2:** Implement useDebateProgress hook and integration
3. **Day 3:** Add styling, animations, and keyboard navigation

---

## Validation Steps

- [ ] Timeline displays all stages
- [ ] Progress updates correctly
- [ ] Clicking stages navigates to sections
- [ ] Keyboard navigation works
- [ ] Mobile responsive
- [ ] Accessibility audit passes
- [ ] Tests pass

---

**Last Updated:** 2025-12-23
