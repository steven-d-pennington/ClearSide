# ClearSide Media Production Pipeline Specification

> Version: 1.0.0
> Last Updated: 2025-12-23
> Status: Draft
> Phase: 2

---

## Table of Contents

1. [Overview](#overview)
2. [Export Formats](#export-formats)
3. [Text Transcript Generation](#text-transcript-generation)
4. [Audio Podcast Generation](#audio-podcast-generation)
5. [Video Generation](#video-generation)
6. [Export Queue System](#export-queue-system)
7. [Storage & Delivery](#storage--delivery)
8. [Cost Analysis](#cost-analysis)

---

## Overview

### Purpose

Transform live debate transcripts into shareable media formats for offline consumption, distribution, and archival.

### Supported Formats

| Format | Extension | Use Case | Priority |
|--------|-----------|----------|----------|
| **Text Transcript** | `.md`, `.pdf` | Reading, sharing documents | P0 |
| **Audio Podcast** | `.mp3` | Listening while driving/exercising | P0 |
| **Video Debate** | `.mp4` | YouTube, social media sharing | P1 |

### Design Goals

| Goal | Implementation |
|------|----------------|
| **High quality output** | Professional-grade TTS voices, visual design |
| **Fast generation** | Text < 5s, Audio < 2min, Video < 10min |
| **Background processing** | Async job queue, user can leave page |
| **Cost efficiency** | Optimize TTS usage, cache generated media |
| **Accessibility** | Subtitles, transcripts, screen reader support |

---

## Export Formats

### Format Comparison

| Feature | Markdown | PDF | MP3 | MP4 |
|---------|----------|-----|-----|-----|
| **File size** | ~50KB | ~200KB | ~5MB | ~50MB |
| **Generation time** | < 5s | < 10s | < 2min | < 10min |
| **Cost per export** | $0 | $0 | ~$0.50 | ~$2.00 |
| **Accessibility** | High | Medium | Medium | High (w/ subs) |
| **Shareability** | Medium | High | High | Very High |
| **Editing** | Easy | Hard | Hard | Very Hard |

### Common Metadata

All export formats include:

```json
{
  "debateId": "uuid",
  "proposition": "Should the US impose a moratorium on AI data centers?",
  "generatedAt": "ISO timestamp",
  "debateDuration": "27:34",
  "exportFormat": "mp3",
  "version": "1.0.0",
  "url": "https://cdn.clearside.com/exports/{debateId}/podcast.mp3"
}
```

---

## Text Transcript Generation

### Markdown Format

**Features:**
- Timestamped speaker labels
- Phase separators
- User intervention markers
- GitHub-flavored markdown
- Syntax highlighting friendly

**Template:**

```markdown
# ClearSide Debate Transcript

**Proposition:** Should the United States impose a moratorium on new AI data centers?

**Date:** December 23, 2025
**Duration:** 27 minutes 34 seconds
**Debate Format:** ClearSide Protocol v1

---

## Phase 1: Opening Statements

### Pro Advocate [00:00 - 02:00]

I argue FOR a moratorium on new AI data centers. My key arguments are:

1. **Energy grid strain threatens reliability**: Current infrastructure cannot
   support exponential AI growth without risking blackouts in residential areas.

2. **Environmental costs outweigh current benefits**: Data centers consume
   massive water and energy resources during a climate crisis.

... (continues)

### Con Advocate [02:00 - 04:00]

I argue AGAINST a moratorium on new AI data centers. My key arguments are:

... (continues)

---

## Phase 2: Constructive Rounds

### Round 1: Economic/Technical Arguments

#### Pro Advocate [04:00 - 06:00]

*Economic argument:*
The cost of grid upgrades to support new data centers would exceed $50 billion...

... (continues)

---

## User Interventions

### [12:45] User Question to Pro Advocate
> "Can you clarify what you mean by grid strain?"

**Pro Advocate Response:**
By grid strain I mean the demand placed on electrical infrastructure when...

---

## Phase 6: Moderator Synthesis

### Moderator [24:00 - 27:00]

**Areas of Agreement:**
- Both sides agree AI growth is significant
- Both acknowledge energy use is rising

**Core Disagreements:**
- Whether private markets or regulation solves energy issues faster

... (continues)

---

*Generated by ClearSide | [Watch the debate](https://clearside.com/debates/{id})*
```

**Implementation:**

```typescript
async function generateMarkdownTranscript(debateId: string): Promise<string> {
  const debate = await getDebate(debateId);
  const utterances = await getUtterances(debateId);
  const interventions = await getInterventions(debateId);

  let markdown = `# ClearSide Debate Transcript\n\n`;
  markdown += `**Proposition:** ${debate.propositionNormalized}\n\n`;
  markdown += `**Date:** ${formatDate(debate.createdAt)}\n`;
  markdown += `**Duration:** ${formatDuration(debate.totalDurationSeconds)}\n`;
  markdown += `**Debate Format:** ClearSide Protocol v1\n\n`;
  markdown += `---\n\n`;

  // Group utterances by phase
  const phases = groupByPhase(utterances);

  for (const [phase, phaseUtterances] of Object.entries(phases)) {
    markdown += `## ${formatPhaseName(phase)}\n\n`;

    for (const utterance of phaseUtterances) {
      const timestamp = formatTimestamp(utterance.timestampMs);
      markdown += `### ${formatSpeaker(utterance.speaker)} [${timestamp}]\n\n`;
      markdown += `${utterance.content}\n\n`;

      // Check for interventions at this timestamp
      const relatedInterventions = interventions.filter(
        i => Math.abs(i.timestampMs - utterance.timestampMs) < 1000
      );

      for (const intervention of relatedInterventions) {
        markdown += `#### ğŸ‘¤ User Intervention\n`;
        markdown += `> ${intervention.content}\n\n`;
        if (intervention.response) {
          markdown += `**${formatSpeaker(intervention.directedTo)} Response:**\n`;
          markdown += `${intervention.response}\n\n`;
        }
      }
    }

    markdown += `---\n\n`;
  }

  markdown += `*Generated by ClearSide | [Watch the debate](https://clearside.com/debates/${debateId})*\n`;

  return markdown;
}
```

### PDF Format

**Features:**
- Professional typesetting
- Table of contents
- Hyperlinked timestamps
- Branded header/footer

**Generation Stack:**
- **Library**: `puppeteer` (headless Chrome) or `pdfkit`
- **Approach**: Render markdown as HTML â†’ Print to PDF
- **Styling**: Custom CSS for professional appearance

**Implementation:**

```typescript
import puppeteer from 'puppeteer';

async function generatePDFTranscript(debateId: string): Promise<Buffer> {
  const markdown = await generateMarkdownTranscript(debateId);
  const html = markdownToHTML(markdown); // Use marked.js

  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  await page.setContent(html, { waitUntil: 'networkidle0' });
  await page.addStyleTag({ path: './styles/transcript.css' });

  const pdf = await page.pdf({
    format: 'A4',
    margin: { top: '20mm', bottom: '20mm', left: '15mm', right: '15mm' },
    printBackground: true,
    displayHeaderFooter: true,
    headerTemplate: `<div style="font-size: 10px; text-align: center; width: 100%;">ClearSide Debate Transcript</div>`,
    footerTemplate: `<div style="font-size: 10px; text-align: center; width: 100%;"><span class="pageNumber"></span> / <span class="totalPages"></span></div>`
  });

  await browser.close();

  return pdf;
}
```

---

## Audio Podcast Generation

### TTS Voice Strategy

**Voice Profiles:**

| Agent | Voice Service | Voice ID | Characteristics |
|-------|---------------|----------|-----------------|
| **Pro Advocate** | ElevenLabs | `Rachel` | Confident, analytical, slightly higher pitch, measured pace |
| **Con Advocate** | ElevenLabs | `Adam` | Thoughtful, skeptical, slightly lower pitch, deliberate |
| **Moderator** | ElevenLabs | `Bella` | Neutral, authoritative, mid-range, clear enunciation |
| **User** | Optional | User's voice or generic narrator | Warm, conversational |

**Alternative Services:**
- **Primary**: ElevenLabs (highest quality, $0.30 per 1K characters)
- **Fallback**: PlayHT ($0.20 per 1K characters, good quality)
- **Budget**: Google Cloud TTS ($4 per 1M characters, acceptable quality)

### Audio Features

**Required:**
- Distinct voices per agent
- Chapter markers at phase transitions
- Metadata (title, description, artwork)
- Normalized audio levels
- MP3 format, 128kbps stereo

**Optional (Phase 2+):**
- Background music during transitions
- Sound effects (subtle cues for speaker changes)
- Intro/outro music
- Dynamic EQ and compression

### Audio Generation Pipeline

```
Transcript JSON
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Text Preprocessing       â”‚
â”‚  â€¢ Split by speaker          â”‚
â”‚  â€¢ Add pauses at phases      â”‚
â”‚  â€¢ Format timestamps         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. TTS Generation           â”‚
â”‚  â€¢ Batch API calls           â”‚
â”‚  â€¢ Voice per speaker         â”‚
â”‚  â€¢ Generate WAV files        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Audio Assembly           â”‚
â”‚  â€¢ Concatenate segments      â”‚
â”‚  â€¢ Add silence (0.5s between)â”‚
â”‚  â€¢ Insert phase markers      â”‚
â”‚  â€¢ (Optional) Add music      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Post-Processing          â”‚
â”‚  â€¢ Normalize volume          â”‚
â”‚  â€¢ Apply light compression   â”‚
â”‚  â€¢ Add metadata              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. Export MP3               â”‚
â”‚  â€¢ 128kbps stereo            â”‚
â”‚  â€¢ Add chapter markers       â”‚
â”‚  â€¢ Embed artwork             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
    MP3 File
```

### Implementation (Node.js)

```typescript
import ElevenLabs from 'elevenlabs-node';
import ffmpeg from 'fluent-ffmpeg';
import fs from 'fs/promises';

const voiceMap = {
  pro: 'EXAVITQu4vr4xnSDxMaL', // Rachel
  con: 'pNInz6obpgDQGcFmaJgB', // Adam
  moderator: 'MF3mGyEYCl7XYWbV9V6O' // Bella
};

async function generatePodcast(debateId: string): Promise<string> {
  const debate = await getDebate(debateId);
  const utterances = await getUtterances(debateId);

  const audioSegments: string[] = [];

  // 1. Generate TTS for each utterance
  for (const utterance of utterances) {
    const voiceId = voiceMap[utterance.speaker];
    const audioPath = `/tmp/${debateId}/${utterance.id}.mp3`;

    await ElevenLabs.textToSpeech({
      apiKey: process.env.ELEVENLABS_API_KEY!,
      text: utterance.content,
      voiceId: voiceId,
      fileName: audioPath,
      modelId: 'eleven_multilingual_v2',
      stability: 0.5,
      similarityBoost: 0.75
    });

    audioSegments.push(audioPath);

    // Add 0.5s silence after each utterance
    const silencePath = `/tmp/${debateId}/silence_${utterance.id}.mp3`;
    await generateSilence(silencePath, 0.5);
    audioSegments.push(silencePath);
  }

  // 2. Concatenate all segments
  const outputPath = `/tmp/${debateId}/podcast.mp3`;
  await concatenateAudio(audioSegments, outputPath);

  // 3. Add metadata and chapter markers
  await addMetadata(outputPath, debate);

  // 4. Upload to storage
  const cdnUrl = await uploadToStorage(outputPath, debateId);

  return cdnUrl;
}

async function concatenateAudio(segments: string[], output: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const command = ffmpeg();

    segments.forEach(segment => {
      command.input(segment);
    });

    command
      .on('end', resolve)
      .on('error', reject)
      .mergeToFile(output, '/tmp/');
  });
}

async function addMetadata(filePath: string, debate: any): Promise<void> {
  // Add ID3 tags
  await ffmpeg(filePath)
    .outputOptions([
      `-metadata title="${debate.propositionNormalized}"`,
      `-metadata artist="ClearSide"`,
      `-metadata album="ClearSide Debates"`,
      `-metadata year="${new Date().getFullYear()}"`,
      `-metadata comment="Generated by ClearSide | clearside.com"`
    ])
    .save(filePath + '.tagged.mp3');

  await fs.rename(filePath + '.tagged.mp3', filePath);
}

// Add chapter markers for podcast apps
async function addChapterMarkers(filePath: string, phases: Phase[]): Promise<void> {
  const chapters = phases.map((phase, index) => ({
    startTime: phase.startTimeMs / 1000,
    title: formatPhaseName(phase.name)
  }));

  // Use mp4chaps or similar tool to add chapters
  // ... implementation depends on format
}
```

### Cost Optimization

**Strategies:**
1. **Cache generated audio**: Store TTS output, reuse if user re-exports
2. **Batch API calls**: ElevenLabs allows batch processing at lower cost
3. **Use cheaper models for testing**: Google TTS for dev, ElevenLabs for prod
4. **Limit exports**: Allow 1 free export, charge for additional (Phase 3)

**Estimated Cost per 27-min debate:**
- Characters: ~15,000 (typical debate)
- ElevenLabs: $0.30 per 1K = **~$4.50**
- PlayHT: $0.20 per 1K = **~$3.00**
- Google TTS: $4 per 1M = **~$0.06**

---

## Video Generation

### Video Concept

**Visual Style:**
- Minimal, professional design
- Debate stage aesthetic (not talking heads)
- Focus on text/subtitles, not avatars
- Brand consistent with ClearSide identity

### Video Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLEARSIDE                                 [Phase 3/6]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚              "Should the US impose a                     â”‚
â”‚           moratorium on AI data centers?"               â”‚
â”‚                                                          â”‚
â”‚                                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚   â”‚   PRO ADVOCATE   â”‚       â”‚   CON ADVOCATE   â”‚      â”‚
â”‚   â”‚   [Active]       â”‚       â”‚                  â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                          â”‚
â”‚   "The cost of grid upgrades to support new data        â”‚
â”‚    centers would exceed $50 billion, diverting          â”‚
â”‚    funds from other critical infrastructure..."         â”‚
â”‚                                                          â”‚
â”‚                                                          â”‚
â”‚  [=======================================] 12:34 / 27:00â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Elements:**
- Header with proposition
- Phase indicator (e.g., "Phase 3/6: Cross-Examination")
- Speaker cards (highlighted when speaking)
- Subtitle area (large, readable text)
- Progress bar with timestamp

### Video Generation Stack

**Recommended: Remotion (React-based)**

| Aspect | Technology |
|--------|------------|
| **Video framework** | Remotion (React components â†’ video) |
| **Audio** | Pre-generated MP3 from podcast pipeline |
| **Rendering** | Remotion Lambda (serverless) or local |
| **Subtitles** | Generated from transcript JSON |
| **Transitions** | Remotion spring animations |
| **Export format** | MP4, H.264, 1080p, 30fps |

**Alternative: FFmpeg + overlays**
- More complex but lower cost
- Generate static frames, overlay text
- Assemble with audio using FFmpeg

### Remotion Implementation

**Video component:**

```tsx
// src/video/DebateVideo.tsx
import { AbsoluteFill, Audio, Sequence, useCurrentFrame, useVideoConfig } from 'remotion';
import { Utterance } from './types';

export const DebateVideo: React.FC<{
  proposition: string;
  utterances: Utterance[];
  audioUrl: string;
}> = ({ proposition, utterances, audioUrl }) => {
  const frame = useCurrentFrame();
  const { fps } = useVideoConfig();

  // Calculate current timestamp in seconds
  const currentTime = frame / fps;

  // Find current utterance based on timestamp
  const currentUtterance = findUtteranceAtTime(utterances, currentTime);

  return (
    <AbsoluteFill style={{ backgroundColor: '#1a1a1a' }}>
      <Audio src={audioUrl} />

      {/* Header */}
      <Header proposition={proposition} />

      {/* Speaker cards */}
      <SpeakerCards
        proActive={currentUtterance?.speaker === 'pro'}
        conActive={currentUtterance?.speaker === 'con'}
      />

      {/* Subtitles */}
      <Subtitles
        text={currentUtterance?.content || ''}
        speaker={currentUtterance?.speaker}
      />

      {/* Progress bar */}
      <ProgressBar currentTime={currentTime} totalDuration={getTotalDuration(utterances)} />
    </AbsoluteFill>
  );
};

// Remotion composition config
export const composition = {
  id: 'DebateVideo',
  component: DebateVideo,
  durationInFrames: calculateFrames(totalDurationSeconds, 30),
  fps: 30,
  width: 1920,
  height: 1080
};
```

**Rendering:**

```typescript
import { bundle } from '@remotion/bundler';
import { renderMedia, selectComposition } from '@remotion/renderer';

async function generateVideo(debateId: string): Promise<string> {
  const debate = await getDebate(debateId);
  const utterances = await getUtterances(debateId);
  const audioUrl = await generatePodcast(debateId); // Reuse audio

  // Bundle Remotion project
  const bundled = await bundle({
    entryPoint: path.join(__dirname, '../video/index.ts'),
    webpackOverride: (config) => config
  });

  // Get composition
  const composition = await selectComposition({
    serveUrl: bundled,
    id: 'DebateVideo',
    inputProps: {
      proposition: debate.propositionNormalized,
      utterances,
      audioUrl
    }
  });

  // Render video
  const outputPath = `/tmp/${debateId}/video.mp4`;
  await renderMedia({
    composition,
    serveUrl: bundled,
    codec: 'h264',
    outputLocation: outputPath,
    inputProps: {
      proposition: debate.propositionNormalized,
      utterances,
      audioUrl
    }
  });

  // Upload to CDN
  const cdnUrl = await uploadToStorage(outputPath, debateId);

  return cdnUrl;
}
```

### Video Optimization

**Strategies:**
- **Render on-demand**: Only generate when user requests
- **Use Remotion Lambda**: Serverless rendering, faster than local
- **Cache rendered videos**: Store for 30 days, reuse if re-exported
- **Limit resolution**: 720p for MVP, 1080p for premium (Phase 3)

**Estimated Cost per video:**
- Remotion Lambda: ~$0.50 per minute = **~$13.50** for 27-min video
- Local rendering: Free but slower (~30 minutes render time)

---

## Export Queue System

### Why a Queue?

| Requirement | Reason |
|-------------|--------|
| **Long-running tasks** | Video generation takes 5-10 minutes |
| **User doesn't wait** | User can close page, get notified when done |
| **Resource management** | Prevent overwhelming server with parallel exports |
| **Retry logic** | Automatically retry failed exports |
| **Priority handling** | Premium users get faster processing (Phase 3) |

### Queue Architecture

```
User requests export
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Export API Endpoint     â”‚
â”‚  POST /api/exports       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Create Export Job       â”‚
â”‚  â€¢ debateId              â”‚
â”‚  â€¢ format (mp3/mp4/pdf)  â”‚
â”‚  â€¢ status: queued        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Add to Queue            â”‚
â”‚  (BullMQ/Redis)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Worker Picks Up Job     â”‚
â”‚  â€¢ Update status         â”‚
â”‚  â€¢ Generate media        â”‚
â”‚  â€¢ Upload to storage     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Job Complete            â”‚
â”‚  â€¢ Update status: done   â”‚
â”‚  â€¢ Store CDN URL         â”‚
â”‚  â€¢ Notify user (email)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implementation (BullMQ)

```typescript
import { Queue, Worker } from 'bullmq';
import Redis from 'ioredis';

const connection = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT!)
});

// Create export queue
export const exportQueue = new Queue('exports', { connection });

// Add export job
export async function requestExport(debateId: string, format: 'md' | 'pdf' | 'mp3' | 'mp4') {
  const job = await exportQueue.add('generate', {
    debateId,
    format,
    requestedAt: Date.now()
  }, {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000
    }
  });

  // Create export record in database
  await createExportRecord({
    id: job.id!,
    debateId,
    format,
    status: 'queued',
    createdAt: new Date()
  });

  return job.id;
}

// Worker to process export jobs
const worker = new Worker('exports', async (job) => {
  const { debateId, format } = job.data;

  // Update status
  await updateExportStatus(job.id!, 'processing');

  let cdnUrl: string;

  // Generate media based on format
  switch (format) {
    case 'md':
      const markdown = await generateMarkdownTranscript(debateId);
      cdnUrl = await uploadTextFile(markdown, debateId, 'md');
      break;

    case 'pdf':
      const pdf = await generatePDFTranscript(debateId);
      cdnUrl = await uploadBinaryFile(pdf, debateId, 'pdf');
      break;

    case 'mp3':
      cdnUrl = await generatePodcast(debateId);
      break;

    case 'mp4':
      cdnUrl = await generateVideo(debateId);
      break;
  }

  // Update status and store URL
  await updateExportStatus(job.id!, 'completed', cdnUrl);

  // Notify user (if email available - Phase 3)
  // await sendEmailNotification(debateId, cdnUrl);

  return { cdnUrl };
}, { connection });

worker.on('completed', (job) => {
  console.log(`Export ${job.id} completed:`, job.returnvalue);
});

worker.on('failed', (job, err) => {
  console.error(`Export ${job?.id} failed:`, err);
  updateExportStatus(job?.id!, 'failed', undefined, err.message);
});
```

### Export Status API

```typescript
// GET /api/exports/:exportId
app.get('/api/exports/:exportId', async (req, res) => {
  const { exportId } = req.params;

  const exportRecord = await getExportRecord(exportId);

  if (!exportRecord) {
    return res.status(404).json({ error: 'Export not found' });
  }

  res.json({
    id: exportRecord.id,
    status: exportRecord.status, // queued, processing, completed, failed
    format: exportRecord.format,
    progress: exportRecord.progress, // 0-100
    cdnUrl: exportRecord.cdnUrl,
    errorMessage: exportRecord.errorMessage,
    createdAt: exportRecord.createdAt,
    completedAt: exportRecord.completedAt
  });
});
```

---

## Storage & Delivery

### Storage Strategy

**Generated Media:**
- **Service**: AWS S3 / Cloudflare R2 / Backblaze B2
- **Bucket structure**: `clearside-exports/{debateId}/{format}/{filename}`
- **Access**: Public read, signed URLs for premium (Phase 3)
- **Retention**: 90 days free, indefinite for saved debates (Phase 3)
- **CDN**: CloudFlare CDN for fast global delivery

### Storage Schema

```sql
CREATE TABLE exports (
  id UUID PRIMARY KEY,
  debate_id UUID NOT NULL REFERENCES debates(id),
  format VARCHAR(10) NOT NULL, -- md, pdf, mp3, mp4
  status VARCHAR(20) NOT NULL, -- queued, processing, completed, failed
  progress INTEGER DEFAULT 0, -- 0-100
  cdn_url TEXT,
  file_size_bytes BIGINT,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  completed_at TIMESTAMP,
  expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '90 days'
);

CREATE INDEX idx_exports_debate_id ON exports(debate_id);
CREATE INDEX idx_exports_status ON exports(status);
```

### CDN Configuration

**CloudFlare Settings:**
- Cache TTL: 30 days
- Browser cache: 7 days
- Always Online: Yes
- Hotlink protection: Yes (prevent bandwidth theft)
- Optimize images: No (preserve media quality)

**S3 Bucket Policy:**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "PublicRead",
      "Effect": "Allow",
      "Principal": "*",
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::clearside-exports/*"
    }
  ]
}
```

### File Naming Convention

```
{debateId}/{format}/
  â”œâ”€ transcript.md
  â”œâ”€ transcript.pdf
  â”œâ”€ podcast.mp3
  â””â”€ debate.mp4

Example:
550e8400-e29b-41d4-a716-446655440000/mp3/podcast.mp3
```

---

## Cost Analysis

### Cost Breakdown per Export (27-min debate)

| Item | Text (MD) | PDF | Audio (MP3) | Video (MP4) |
|------|-----------|-----|-------------|-------------|
| **Computation** | $0.00 | $0.01 | $0.10 | $13.50 |
| **TTS API** | â€” | â€” | $4.50 | $4.50 |
| **Storage (90 days)** | $0.00 | $0.00 | $0.01 | $0.15 |
| **Bandwidth (10 downloads)** | $0.00 | $0.00 | $0.05 | $0.50 |
| **TOTAL** | **$0.00** | **$0.01** | **$4.66** | **$18.65** |

### Cost Optimization Strategies

**Phase 2 (MVP):**
- Limit to 1-2 free exports per debate
- Cache aggressively (reuse if debate unchanged)
- Use cheaper TTS for testing
- Local video rendering (slower but free)

**Phase 3 (Freemium):**
- Free: 3 text exports, 1 audio, 0 video
- Pro ($9/month): Unlimited text/audio, 5 videos
- Enterprise: Custom limits

**Phase 4 (Scale):**
- Tiered pricing based on usage
- Pre-rendered popular debates
- Sponsorship/ads in free videos

---

## Appendix A: Export UI Flow

### User Experience

```
User views completed debate
   â†“
Clicks "Export" button
   â†“
Modal shows format options:
  [ğŸ“„ Text (MD/PDF)] [ğŸ§ Audio (MP3)] [ğŸ¬ Video (MP4)]
   â†“
User selects format (e.g., MP3)
   â†“
"Generating podcast..." modal
Progress indicator: [=====>    ] 45%
Estimated time: 1 minute remaining
   â†“
Generation complete!
"Your podcast is ready"
[Download] [Copy Link] [Share]
   â†“
User downloads MP3
```

### Frontend Components

```tsx
function ExportModal({ debateId }: { debateId: string }) {
  const [selectedFormat, setSelectedFormat] = useState<ExportFormat | null>(null);
  const [exportStatus, setExportStatus] = useState<ExportStatus | null>(null);

  const handleExport = async (format: ExportFormat) => {
    setSelectedFormat(format);

    // Request export
    const exportId = await requestExport(debateId, format);

    // Poll for status
    const interval = setInterval(async () => {
      const status = await getExportStatus(exportId);
      setExportStatus(status);

      if (status.status === 'completed' || status.status === 'failed') {
        clearInterval(interval);
      }
    }, 2000); // Poll every 2 seconds
  };

  return (
    <Modal>
      {!selectedFormat && (
        <FormatSelector onSelect={handleExport} />
      )}

      {selectedFormat && exportStatus && (
        <ExportProgress
          format={selectedFormat}
          status={exportStatus}
        />
      )}
    </Modal>
  );
}
```

---

## Appendix B: Future Enhancements

### Phase 3+ Features

| Feature | Description |
|---------|-------------|
| **Custom branding** | Add company logos to videos |
| **Multiple languages** | TTS in Spanish, French, etc. |
| **Custom music** | User-selected background tracks |
| **Animated charts** | Visualize evidence/data in videos |
| **Interactive transcripts** | Click timestamp to jump in video |
| **Playlist generation** | Combine multiple debates into series |

---

## Appendix C: Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-12-23 | Initial media production specification |

---

*Transform debates into shareable media for maximum reach and impact.*
